[
  {
    "objectID": "PBMC3k/pages/scRNA-seq_PBMC3k.html",
    "href": "PBMC3k/pages/scRNA-seq_PBMC3k.html",
    "title": "scRNAseq_PBMC3k",
    "section": "",
    "text": "This Tutorial aims to provide additional functions and exercises to accompany the Seurat - Guided Clustering Tutorial found here.\nDownload the publicly available Peripheral Blood Mononuclear Cells (PBMC) dataset as shown below. Then we will follow the Seurat Tutorial for the main processing steps. Finally, we will switch to this tutorial to explore the structure of the Seurat object and additional functions for the analysis of single cell data.\n\n\n\nWhat is the structure of the Seurat Object?\nInspect different layers and metadata information\nAdd and tabulate metadata information\n\nExplore various visualization options for single cell data\n\n\n# Load libraries\nlibrary(dplyr)\nlibrary(Seurat)\nlibrary(patchwork)\nlibrary(ggplot2)"
  },
  {
    "objectID": "PBMC3k/pages/scRNA-seq_PBMC3k.html#objectives",
    "href": "PBMC3k/pages/scRNA-seq_PBMC3k.html#objectives",
    "title": "scRNAseq_PBMC3k",
    "section": "",
    "text": "What is the structure of the Seurat Object?\nInspect different layers and metadata information\nAdd and tabulate metadata information\n\nExplore various visualization options for single cell data\n\n\n# Load libraries\nlibrary(dplyr)\nlibrary(Seurat)\nlibrary(patchwork)\nlibrary(ggplot2)"
  },
  {
    "objectID": "PBMC3k/pages/scRNA-seq_PBMC3k.html#where-is-everything-stored",
    "href": "PBMC3k/pages/scRNA-seq_PBMC3k.html#where-is-everything-stored",
    "title": "scRNAseq_PBMC3k",
    "section": "Where is everything stored?",
    "text": "Where is everything stored?\n\n\n\nSource: https://moodle.france-bioinformatique.fr/pluginfile.php/836/mod_resource/content/5/06_The_Seurat_object.pdf\n@ assays: A list of containers for data matrices (features x barcodes). The default one is named $RNA. Additional assays can be stored, e.g. $ADT for Antibody-derived tags.\n$ RNA:\n@ layers: A list containing expression matrices; each matrix is a two-dimensional object containing some subset of cells and features defined in the cells and features slots.\n  \n  $ counts\n  $ data\n  $ scale.data\n\n@ meta.data for features \n@ meta.data: a data frame containing metadata information for cells\n@ reductions: a list of dimension reduction spaces (e.g. PCA, UMAP)\n@ commands: keeps tracks of the processing steps the object underent"
  },
  {
    "objectID": "PBMC3k/pages/scRNA-seq_PBMC3k.html#inspect-the-seurat-object",
    "href": "PBMC3k/pages/scRNA-seq_PBMC3k.html#inspect-the-seurat-object",
    "title": "scRNAseq_PBMC3k",
    "section": "Inspect the Seurat Object",
    "text": "Inspect the Seurat Object\n\nCheck the dimensions of the object\n\n👀 There are multiple ways to perform the same job in Seurat and general in R.\n\n\n# Dimensions of object: features x cells\ndim(pbmc)\n\n[1] 13714  2700\n\n# Number of features\nnrow(pbmc)\n\n[1] 13714\n\n# Number of cells\nncol(pbmc)\n\n[1] 2700\n\n# Retrieve features rownames(pbmc) Features(pbmc) %&gt;% length()\nFeatures(pbmc) %&gt;%\n    head()\n\n[1] \"AL627309.1\"    \"AP006222.2\"    \"RP11-206L10.2\" \"RP11-206L10.9\"\n[5] \"LINC00115\"     \"NOC2L\"        \n\n# Retrieve cells colnames(pbmc) Cells(pbmc) %&gt;% length()\nCells(pbmc) %&gt;%\n    head()\n\n[1] \"AAACATACAACCAC-1\" \"AAACATTGAGCTAC-1\" \"AAACATTGATCAGC-1\" \"AAACCGTGCTTCCG-1\"\n[5] \"AAACCGTGTATGCG-1\" \"AAACGCACTGGTAC-1\"\n\n\n\n\nInspect the Layers\n\nLayers: two-dimensional expression matrices of features x barcodes. What are the assays and layers of the PBMC Object? * Raw counts: layer = ‘counts’ * Normalized data: layer = ‘data’ * Scaled data: layer = ‘scale.data’\n\n\n# Inspect Layers\nprint(paste(\"The Assay of the Seurat object is: \", Assays(pbmc)))\n\n[1] \"The Assay of the Seurat object is:  RNA\"\n\nLayers(pbmc)\n\n[1] \"counts\"     \"data\"       \"scale.data\"\n\n\n\n# Raw counts\npbmc@assays$RNA$counts[6:10, 1:20]\n\n5 x 20 sparse Matrix of class \"dgCMatrix\"\n\n\n                                                    \nNOC2L        . . . . . . . . . . . 1 . . . . . . . .\nKLHL17       . . . . . . . . . . . . . . . . . . . .\nPLEKHN1      . . . . . . . . . . . . . . . . . . . .\nRP11-54O7.17 . . . . . . . . . . . . . . . . . . . .\nHES4         . . . . . . . . . . . . . . . . . . 1 .\n\n# Normalized counts\npbmc@assays$RNA$data[6:10, 1:20]\n\n5 x 20 sparse Matrix of class \"dgCMatrix\"\n\n\n                                                                  \nNOC2L        . . . . . . . . . . . 1.646272 . . . . . . .        .\nKLHL17       . . . . . . . . . . . .        . . . . . . .        .\nPLEKHN1      . . . . . . . . . . . .        . . . . . . .        .\nRP11-54O7.17 . . . . . . . . . . . .        . . . . . . .        .\nHES4         . . . . . . . . . . . .        . . . . . . 1.157353 .\n\n# Scaled data\npbmc@assays$RNA$scale.data[6:10, 1:3]\n\n             AAACATACAACCAC-1 AAACATTGAGCTAC-1 AAACATTGATCAGC-1\nNOC2L             -0.30161350      -0.28815004      -0.33854318\nKLHL17            -0.07938548      -0.10232231      -0.01647077\nPLEKHN1           -0.04462180      -0.03918564      -0.05953296\nRP11-54O7.17      -0.03368993      -0.03464305      -0.03107556\nHES4              -0.28480730      -0.33568104      -0.14526286\n\n\n\n\nInspect Cell Metadata\n\nCell Metadata: Data frame that stores information for cells in the dataset. It can be accessed by running object@metadata or object[[]].\n\n\n# Column names of meta.data colnames(pbmc[[]])\npbmc@meta.data %&gt;%\n    names()\n\n[1] \"orig.ident\"      \"nCount_RNA\"      \"nFeature_RNA\"    \"percent.mt\"     \n[5] \"RNA_snn_res.0.5\" \"seurat_clusters\"\n\n\n\n# Check metadata column\nhead(pbmc@meta.data, 2)\n\n                 orig.ident nCount_RNA nFeature_RNA percent.mt RNA_snn_res.0.5\nAAACATACAACCAC-1     pbmc3k       2419          779   3.017776               1\nAAACATTGAGCTAC-1     pbmc3k       4903         1352   3.793596               3\n                 seurat_clusters\nAAACATACAACCAC-1               1\nAAACATTGAGCTAC-1               3\n\n\n\n# View the Cell Identities\nIdents(pbmc) %&gt;%\n    head()\n\nAAACATACAACCAC-1 AAACATTGAGCTAC-1 AAACATTGATCAGC-1 AAACCGTGCTTCCG-1 \n      CD14+ Mono                B       CD14+ Mono     FCGR3A+ Mono \nAAACCGTGTATGCG-1 AAACGCACTGGTAC-1 \n              NK       CD14+ Mono \n9 Levels: Naive CD4 T CD14+ Mono Memory CD4 T B CD8 T FCGR3A+ Mono NK ... Platelet\n\n\n\n\nInspect Feature Metadata\n\nFeature Metadata: Data frame that stores information for features in the dataset. It can be accessed by running object@assays$RNA[[]]\n\nWhat is the information stored in the Feature Metadata?\n\n# Show Feature Metadata\ndim(pbmc[[\"RNA\"]][[]])\n\n[1] 13714     8\n\npbmc[[\"RNA\"]][[]] %&gt;%\n    names()\n\n[1] \"vf_vst_counts_mean\"                  \"vf_vst_counts_variance\"             \n[3] \"vf_vst_counts_variance.expected\"     \"vf_vst_counts_variance.standardized\"\n[5] \"vf_vst_counts_variable\"              \"vf_vst_counts_rank\"                 \n[7] \"var.features\"                        \"var.features.rank\"                  \n\nhead(pbmc[[\"RNA\"]][[]], 2)\n\n           vf_vst_counts_mean vf_vst_counts_variance\nAL627309.1        0.003333333            0.003323453\nAP006222.2        0.001111111            0.001110288\n           vf_vst_counts_variance.expected vf_vst_counts_variance.standardized\nAL627309.1                     0.003575582                           0.9294859\nAP006222.2                     0.001112798                           0.9977442\n           vf_vst_counts_variable vf_vst_counts_rank var.features\nAL627309.1                  FALSE                 NA         &lt;NA&gt;\nAP006222.2                  FALSE                 NA         &lt;NA&gt;\n           var.features.rank\nAL627309.1                NA\nAP006222.2                NA\n\n\nCheck the variable genes length and top members\n\n# Variable Features length and top genes\nlength(VariableFeatures(pbmc))\n\n[1] 2000\n\nhead(VariableFeatures(pbmc))\n\n[1] \"PPBP\"   \"S100A9\" \"IGLL5\"  \"LYZ\"    \"GNLY\"   \"FTL\"   \n\n\nWe can also retrieve the Variable Features from the Metadata Table\n\n# Retrieve variable features from metadata\npbmc@assays$RNA[[c(\"var.features\", \"var.features.rank\")]] %&gt;%\n    dplyr::filter(!is.na(var.features)) %&gt;%\n    dplyr::arrange(var.features.rank) %&gt;%\n    head()\n\n       var.features var.features.rank\nPPBP           PPBP                 1\nS100A9       S100A9                 2\nIGLL5         IGLL5                 3\nLYZ             LYZ                 4\nGNLY           GNLY                 5\nFTL             FTL                 6"
  },
  {
    "objectID": "PBMC3k/pages/scRNA-seq_PBMC3k.html#add-and-tabulate-metadata-information",
    "href": "PBMC3k/pages/scRNA-seq_PBMC3k.html#add-and-tabulate-metadata-information",
    "title": "scRNAseq_PBMC3k",
    "section": "Add and Tabulate MetaData information",
    "text": "Add and Tabulate MetaData information\n\nWhat is the total counts per gene?\n\n\nWhat is the number of cells with non-zero expression per gene?\nCompute Metadata information for Features\n\n# Create an object for the count matrix for easy access\nmtx &lt;- pbmc@assays$RNA$counts\n\n# For each gene, calculate number of counts across all cells\nn_counts &lt;- rowSums(mtx)\n\n# For each gene, calculate number of cells with non 0 counts\nn_cells &lt;- apply(mtx, 1, function(c) sum(c != 0))\n\nhead(n_counts)\n\n   AL627309.1    AP006222.2 RP11-206L10.2 RP11-206L10.9     LINC00115 \n            9             3             5             3            18 \n        NOC2L \n          288 \n\nhead(n_cells)\n\n   AL627309.1    AP006222.2 RP11-206L10.2 RP11-206L10.9     LINC00115 \n            9             3             5             3            18 \n        NOC2L \n          258 \n\n\nAdd this information in the Feature Metadata\n\npbmc@assays$RNA[[\"n_counts\"]] &lt;- n_counts\npbmc@assays$RNA[[\"n_cells\"]] &lt;- n_cells\n\npbmc[[\"RNA\"]][[]] %&gt;%\n    head(2)\n\n           vf_vst_counts_mean vf_vst_counts_variance\nAL627309.1        0.003333333            0.003323453\nAP006222.2        0.001111111            0.001110288\n           vf_vst_counts_variance.expected vf_vst_counts_variance.standardized\nAL627309.1                     0.003575582                           0.9294859\nAP006222.2                     0.001112798                           0.9977442\n           vf_vst_counts_variable vf_vst_counts_rank var.features\nAL627309.1                  FALSE                 NA         &lt;NA&gt;\nAP006222.2                  FALSE                 NA         &lt;NA&gt;\n           var.features.rank n_counts n_cells\nAL627309.1                NA        9       9\nAP006222.2                NA        3       3\n\n\n\n\nRetrieve mitochondrial genes and annotate the Feature Metadata\n\n# Retrieve mitochondrial with the grepl function\nmito.genes &lt;- Features(pbmc)[which(grepl(\"MT-\", Features(pbmc)))]\n\n# pbmc@assays$RNA[[]] |&gt; mutate(mito.genes = case_when( grepl('MT-',\n# row.names(pbmc@assays$RNA)) ~ TRUE, .default=FALSE))\n\n# Add a new metadata column using dplyr::mutate and case_when\npbmc@assays$RNA[[]] &lt;- pbmc@assays$RNA[[]] %&gt;%\n    mutate(mito.genes = case_when(grepl(\"MT-\", row.names(pbmc@assays$RNA)) ~ TRUE, .default = FALSE))\n\n# Retrieve MT features\npbmc@assays$RNA[[]] %&gt;%\n    dplyr::filter(mito.genes == TRUE) %&gt;%\n    row.names()\n\n [1] \"MT-ND1\"  \"MT-ND2\"  \"MT-CO1\"  \"MT-CO2\"  \"MT-ATP8\" \"MT-ATP6\" \"MT-CO3\" \n [8] \"MT-ND3\"  \"MT-ND4L\" \"MT-ND4\"  \"MT-ND5\"  \"MT-ND6\"  \"MT-CYB\" \n\n\n\n\nHow do we add information on Cell Identities to the Cell Metadata?\n\n\n                 orig.ident nCount_RNA nFeature_RNA percent.mt RNA_snn_res.0.5\nAAACATACAACCAC-1     pbmc3k       2419          779   3.017776               1\nAAACATTGAGCTAC-1     pbmc3k       4903         1352   3.793596               3\n                 seurat_clusters identities\nAAACATACAACCAC-1               1 CD14+ Mono\nAAACATTGAGCTAC-1               3          B\n\n\n\n\nHow many cells are there per cluster?\nTry to summarize the information on clusters using dplyr\n\n# Number of cells per cluster\npbmc@meta.data %&gt;%\n    dplyr::group_by(seurat_clusters) %&gt;%\n    dplyr::count()\n\n# A tibble: 9 × 2\n# Groups:   seurat_clusters [9]\n  seurat_clusters     n\n  &lt;fct&gt;           &lt;int&gt;\n1 0                 636\n2 1                 534\n3 2                 494\n4 3                 350\n5 4                 326\n6 5                 157\n7 6                 155\n8 7                  33\n9 8                  15\n\n\nUse dplyr and ggplot to count the number of cells per clusters\n\n#\npbmc@meta.data %&gt;%\n    ggplot(aes(identities)) + geom_bar()\n\n\n\n\n\n\n\n\n\n#\npbmc@meta.data %&gt;%\n    ggplot(aes(identities, fill = identities)) + geom_bar() + scale_fill_manual(values = rep(c(\"red\",\n    \"blue\", \"green\"), 3))\n\n\n\n\n\n\n\n\nAlternatively, we can group the cells based on the clusters and pass it to ggplot. Here, we also color annotate the groups using fill=identities. geom_bar() counts the number of cases at each x position. Instead geom_col() uses stat_identity(): it leaves the data as is, thus we first need to count the number of occurrences in each group.\n\n# Use the geom_col function\npbmc@meta.data %&gt;%\n    dplyr::group_by(identities) %&gt;%\n    dplyr::count() %&gt;%\n    ggplot(aes(x = identities, y = n, fill = identities)) + geom_bar(stat = \"identity\") + theme(axis.text.x = element_text(angle = 45,\n    vjust = 0.8))\n\n\n\n\n\n\n\n\n\n\nHow do we remove columns from metadata?\n\n# For a specific column\npbmc$identities &lt;- NULL\n\n# For several columns with a string pattern pbmc@meta.data &lt;- pbmc@meta.data[, !grepl('ident',\n# colnames(pbmc@meta.data))]\n\nhead(pbmc@meta.data)\n\n                 orig.ident nCount_RNA nFeature_RNA percent.mt RNA_snn_res.0.5\nAAACATACAACCAC-1     pbmc3k       2419          779  3.0177759               1\nAAACATTGAGCTAC-1     pbmc3k       4903         1352  3.7935958               3\nAAACATTGATCAGC-1     pbmc3k       3147         1129  0.8897363               1\nAAACCGTGCTTCCG-1     pbmc3k       2639          960  1.7430845               5\nAAACCGTGTATGCG-1     pbmc3k        980          521  1.2244898               6\nAAACGCACTGGTAC-1     pbmc3k       2163          781  1.6643551               1\n                 seurat_clusters\nAAACATACAACCAC-1               1\nAAACATTGAGCTAC-1               3\nAAACATTGATCAGC-1               1\nAAACCGTGCTTCCG-1               5\nAAACCGTGTATGCG-1               6\nAAACGCACTGGTAC-1               1"
  },
  {
    "objectID": "PBMC3k/pages/scRNA-seq_PBMC3k.html#visualization-options-with-seurat",
    "href": "PBMC3k/pages/scRNA-seq_PBMC3k.html#visualization-options-with-seurat",
    "title": "scRNAseq_PBMC3k",
    "section": "Visualization options with Seurat",
    "text": "Visualization options with Seurat\nSeurat offers a number of options for visualizing expression of genes.\n\n# Create vector with genes\nfeatures &lt;- c(\"LYZ\", \"CCL5\", \"IL32\", \"PTPRCAP\", \"FCGR3A\", \"PF4\", \"MS4A1\")\n\n\nRidge plots\nVisualize density distributions using Ridge plots\n\n# Ridge plots - from ggridges. Visualize single cell expression distributions in each cluster\nRidgePlot(pbmc, features = c(\"LYZ\", \"CCL5\", \"MS4A1\"), ncol = 1)\n\n\n\n\n\n\n\n\n\n\nDotplots\nDotplots summarize gene expression for several genes simultaneously. The color of the dot corresponds to the average expression level of the gene. The size of the dot represents the percentage of cells expressing the feature in each cluster.\n\n# Draw a dot plot for the features of interest\nDotPlot(pbmc, features = features) + RotatedAxis()\n\n\n\n\n\n\n\n\n\nTry to use a different color palette.\n\nCreate a dotplot with the top differential markers for each cluster.\n\n# find markers for every cluster compared to all remaining cells, report only the positive\n# ones\npbmc.markers &lt;- FindAllMarkers(pbmc, only.pos = TRUE)\n\n\n# Retrieve the top differentially expressed genes for each cluster\ntop.genes &lt;- pbmc.markers %&gt;%\n    dplyr::filter(p_val_adj &lt; 0.01 & avg_log2FC &gt; 1) %&gt;%\n    dplyr::group_by(cluster) %&gt;%\n    dplyr::arrange(p_val_adj) %&gt;%\n    dplyr::slice(1:2) %&gt;%\n    dplyr::pull(gene)\n\ntop.genes\n\n [1] \"LDHB\"          \"CCR7\"          \"LTB\"           \"LDHB\"         \n [5] \"S100A8\"        \"LGALS2\"        \"CD79A\"         \"MS4A1\"        \n [9] \"CCL5\"          \"GZMK\"          \"CDKN1C\"        \"RP11-290F20.3\"\n[13] \"GZMB\"          \"FGFBP2\"        \"FCER1A\"        \"SERPINF1\"     \n[17] \"GP9\"           \"AP001189.4\"   \n\n\nDraw a dot plot for the top differentially expressed genes in each cluster\n\n# Draw a dot plot for the top differentially expressed\nDotPlot(pbmc, features = top.genes) + RotatedAxis()\n\nError in `levels&lt;-`(`*tmp*`, value = as.character(levels)): factor level [4] is duplicated\n\n\n\n\nSingle cell heatmaps\nHeatmap of gene expression across all single cells for selected features\n\n# Single cell heatmap of feature expression\nDoHeatmap(subset(pbmc, downsample = 100), features = features, size = 3)\n\n\n\n\n\n\n\n\nHeatmap of expression for the top Variable genes\n\n# Single cell heatmap of feature expression\nDoHeatmap(subset(pbmc, downsample = 100), features = VariableFeatures(pbmc)[1:40], size = 2)\n\n\n\n\n\n\n\n\n\n\nEvaluate the co-expression of two features\nWith FeaturePlot() we visualize the expression of a gene in low dimensional space. But sometimes it is informative to evaluate the co-expression of two features. This can be achieved by projecting the expression of the features simultaneoulsy on the low dimensional space and/or check their correlation.\n\n# Visualize co-expression of two features simultaneously\nFeaturePlot(pbmc, features = c(\"MS4A1\", \"CD79A\"), blend = TRUE)\n\n\n\n\n\n\n\n\nVisualize how two features correlate in their expression using a scatter plot. The plot corroborates the results of the above heatmap showing that PF4 and CCL5 expression overlaps in platelets.\n\nplot1 &lt;- FeatureScatter(pbmc, feature1 = \"LYZ\", feature2 = \"CCL5\") + NoLegend()\nplot2 &lt;- FeatureScatter(pbmc, feature1 = \"PF4\", feature2 = \"CCL5\") + NoLegend()\nplot3 &lt;- FeatureScatter(pbmc, feature1 = \"MS4A1\", feature2 = \"CD79A\")\nplot1 + plot2 + plot3\n\n\n\n\n\n\n\n\n\n\nSplit visualization across groups\nOften we need to assess gene expression with respect to other metadata information, e.g. batches, percent.mt, integrated datasets, patients etc. This can be achieved by splitting the visualization\nThe VinPlot() can be utilized not only to visualize gene expression distributions. In the example below, we check how the number of genes or percentage of mitochondrial counts compares across cell clusters.\n\nVlnPlot(pbmc, features = c(\"nFeature_RNA\", \"percent.mt\"), ncol = 2)\n\n\n\n\n\n\n\n\nLet’s create a dummy metadata variable. This could represent different patientID, gender, protocol, hospital, disease stage or any other variable of relevance, the distribution of which needs to be evaluated.\n\n# Add a new metadata column with information on group membership\npbmc$groups &lt;- sample(c(\"group1\", \"group2\"), size = ncol(pbmc), replace = TRUE)\n\n# Tabulate data for clusters and groups\ntable(pbmc$groups, pbmc$identities)\n\nError in `x[[i, drop = TRUE]]`:\n! 'identities' not found in this Seurat object\n \n\n\nWe can plot the number of cells per group\n\npbmc@meta.data %&gt;%\n    dplyr::group_by(identities) %&gt;%\n    ggplot(aes(identities, fill = groups)) + geom_bar()\n\nError in `dplyr::group_by()`:\n! Must group by variables found in `.data`.\n✖ Column `identities` is not found.\n\n# #Using geom_bar(stat='identity') the bar heights will be given by the y values we pass\n# rather than the counts pbmc@meta.data %&gt;% group_by(identities, groups) %&gt;% count() %&gt;%\n# ggplot(aes(identities, n, fill=groups)) + geom_bar(stat='identity')\n\nWhat if we want to calculate the percentage of group_1 and group_2 in each cluster?\n\npbmc@meta.data %&gt;%\n    dplyr::count(identities, groups) %&gt;%\n    dplyr::group_by(identities) %&gt;%\n    dplyr::mutate(prop = prop.table(n)) %&gt;%\n    # head()\nggplot(aes(identities, prop, fill = groups)) + geom_bar(stat = \"identity\")\n\nError in `dplyr::count()`:\n! Must group by variables found in `.data`.\n✖ Column `identities` is not found.\n\n\n\n\nInteractive plotting features\nWhat if we could hoover over a cell and reveal its identity and metadata information?\nSeurat allows for interactive plots taking advantge of R’s plotly graphing library. This functionality supports any ggplot2-based scatter plot that includes a geom_point layer. We first need to create a scatter plot, e.g. using DimPlot() or FeaturePlot(), and then pass the resulting plot to HoverLocator() for interactivity. We can also Fetch metadata information to display along with the cell’s identity.\n\n# Instantiate an interactive plot using FeaturePlot() and then pass it to HoverLocator()\nplot &lt;- FeaturePlot(pbmc, features = \"MS4A1\")\nHoverLocator(plot = plot, information = FetchData(pbmc, vars = c(\"ident\", \"seurat_clusters\", \"nFeature_RNA\",\n    \"percent.mt\")))"
  },
  {
    "objectID": "PBMC3k/pages/scRNA-seq_PBMC3k.html#additional-analyses",
    "href": "PBMC3k/pages/scRNA-seq_PBMC3k.html#additional-analyses",
    "title": "scRNAseq_PBMC3k",
    "section": "Additional analyses",
    "text": "Additional analyses\n\nCalculate quality control metrics for ribosomal genes\n\nIdentify ribosomal genes by their distinct prefixes and calculate their percentage of counts per cell.\nCreate a metadata column in the Features Metadata\n\nHow many ribosomal genes are there?\n\nTip: Ribosomal genes have aprefix of RPS or RPL\n\n\n\n                 orig.ident nCount_RNA nFeature_RNA percent.mt RNA_snn_res.0.5\nAAACATACAACCAC-1     pbmc3k       2419          779  3.0177759               1\nAAACATTGAGCTAC-1     pbmc3k       4903         1352  3.7935958               3\nAAACATTGATCAGC-1     pbmc3k       3147         1129  0.8897363               1\nAAACCGTGCTTCCG-1     pbmc3k       2639          960  1.7430845               5\nAAACCGTGTATGCG-1     pbmc3k        980          521  1.2244898               6\nAAACGCACTGGTAC-1     pbmc3k       2163          781  1.6643551               1\n                 seurat_clusters groups percent.ribo\nAAACATACAACCAC-1               1 group2     43.69574\nAAACATTGAGCTAC-1               3 group1     42.40261\nAAACATTGATCAGC-1               1 group1     31.68097\nAAACCGTGCTTCCG-1               5 group1     24.25161\nAAACCGTGTATGCG-1               6 group1     14.89796\nAAACGCACTGGTAC-1               1 group1     36.19972\n\n\n\n\n\n\n\n\n\n\nVlnPlot(pbmc, features = c(\"nFeature_RNA\", \"nCount_RNA\", \"percent.mt\", \"percent.ribo\"), ncol = 4,\n    group.by = \"orig.ident\")\n\n\n\n\n\n\n\n\n\n\nExplore additional PCA components\nMake a plot of PC1 versus PC3 or PC1 versus PC4.\n\nTip: Check if the function provides a relevant parameter.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nProject the percentage of mitochondrial counts on PCA space\nCheck the distribution of percent.mt in PC3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nProject on PCA space the expression of the top genes that define each PC\n\n# Retrieve top genes for PCs\nprint(pbmc[[\"pca\"]], dims = 1:3, nfeatures = 5)\n\nPC_ 1 \nPositive:  MALAT1, LTB, IL32, CD2, ACAP1 \nNegative:  CST3, TYROBP, LST1, AIF1, FTL \nPC_ 2 \nPositive:  CD79A, MS4A1, TCL1A, HLA-DQA1, HLA-DRA \nNegative:  NKG7, PRF1, GZMA, CST7, GZMB \nPC_ 3 \nPositive:  HLA-DQA1, CD79A, CD79B, HLA-DQB1, HLA-DPB1 \nNegative:  PPBP, PF4, SDPR, SPARC, GNG11 \n\n\n\nFeaturePlot(object = pbmc, features = c(\"CST3\", \"MALAT1\"), reduction = \"pca\")\n\n\n\n\n\n\n\n\n\n\nPlot average expression of genes defining the first principal component\n\n# Create a vector that contains the top five negative genes for PC1\ngenes.pc1 &lt;- pbmc[[\"pca\"]]@feature.loadings %&gt;%\n    as.data.frame %&gt;%\n    dplyr::select(PC_1) %&gt;%\n    dplyr::arrange(PC_1) %&gt;%\n    head(5) %&gt;%\n    rownames()\n\ngenes.pc1\n\n[1] \"CST3\"   \"TYROBP\" \"LST1\"   \"AIF1\"   \"FTL\"   \n\n\nFirst we will calculate the average expression of the genes across all cells in the dataset\n\n# compute average expression\nmean.exp &lt;- colMeans(pbmc@assays$RNA$data[genes.pc1, ], na.rm = TRUE) %&gt;%\n    as.data.frame() %&gt;%\n    stats::setNames(\"score.pc1\")\n\nclass(mean.exp)\n\n[1] \"data.frame\"\n\nhead(mean.exp)\n\n                 score.pc1\nAAACATACAACCAC-1 0.7848191\nAAACATTGAGCTAC-1 1.0573239\nAAACATTGATCAGC-1 0.9407809\nAAACCGTGCTTCCG-1 4.2034002\nAAACCGTGTATGCG-1 1.5269735\nAAACGCACTGGTAC-1 0.7896914\n\n\nWe will then extract the Metadata table from the Seurat object\n\n# Extract Metadata Table\nCellsMeta = pbmc@meta.data\nprint(class(CellsMeta))\n\n[1] \"data.frame\"\n\nprint(head(CellsMeta))\n\n                 orig.ident nCount_RNA nFeature_RNA percent.mt RNA_snn_res.0.5\nAAACATACAACCAC-1     pbmc3k       2419          779  3.0177759               1\nAAACATTGAGCTAC-1     pbmc3k       4903         1352  3.7935958               3\nAAACATTGATCAGC-1     pbmc3k       3147         1129  0.8897363               1\nAAACCGTGCTTCCG-1     pbmc3k       2639          960  1.7430845               5\nAAACCGTGTATGCG-1     pbmc3k        980          521  1.2244898               6\nAAACGCACTGGTAC-1     pbmc3k       2163          781  1.6643551               1\n                 seurat_clusters groups percent.ribo\nAAACATACAACCAC-1               1 group2     43.69574\nAAACATTGAGCTAC-1               3 group1     42.40261\nAAACATTGATCAGC-1               1 group1     31.68097\nAAACCGTGCTTCCG-1               5 group1     24.25161\nAAACCGTGTATGCG-1               6 group1     14.89796\nAAACGCACTGGTAC-1               1 group1     36.19972\n\n\nLet’s check that the cells are the same\n\n# Check if the cells in the two objects to be merged are identical\nidentical(row.names(CellsMeta), row.names(mean.exp))\n\n[1] TRUE\n\n\nPerform a merge between the two data.frames\n\nlibrary(tidyverse)\n# full_join(as_tibble(CellsMeta, rownames = 'id'), as_tibble(mean.exp, rownames = 'id'), by =\n# 'id')\nCellsMetaPC1 &lt;- merge(CellsMeta, mean.exp, by = \"row.names\", sort = FALSE) %&gt;%\n    column_to_rownames(var = \"Row.names\") %&gt;%\n    dplyr::select(\"score.pc1\")\n\nhead(CellsMetaPC1)\n\n                 score.pc1\nAAACATACAACCAC-1 0.7848191\nAAACATTGAGCTAC-1 1.0573239\nAAACATTGATCAGC-1 0.9407809\nAAACCGTGCTTCCG-1 4.2034002\nAAACCGTGTATGCG-1 1.5269735\nAAACGCACTGGTAC-1 0.7896914\n\n\n\n# Add new variable into Metadata Table\npbmc &lt;- AddMetaData(pbmc, CellsMetaPC1)\nhead(pbmc@meta.data)\n\n                 orig.ident nCount_RNA nFeature_RNA percent.mt RNA_snn_res.0.5\nAAACATACAACCAC-1     pbmc3k       2419          779  3.0177759               1\nAAACATTGAGCTAC-1     pbmc3k       4903         1352  3.7935958               3\nAAACATTGATCAGC-1     pbmc3k       3147         1129  0.8897363               1\nAAACCGTGCTTCCG-1     pbmc3k       2639          960  1.7430845               5\nAAACCGTGTATGCG-1     pbmc3k        980          521  1.2244898               6\nAAACGCACTGGTAC-1     pbmc3k       2163          781  1.6643551               1\n                 seurat_clusters groups percent.ribo score.pc1\nAAACATACAACCAC-1               1 group2     43.69574 0.7848191\nAAACATTGAGCTAC-1               3 group1     42.40261 1.0573239\nAAACATTGATCAGC-1               1 group1     31.68097 0.9407809\nAAACCGTGCTTCCG-1               5 group1     24.25161 4.2034002\nAAACCGTGTATGCG-1               6 group1     14.89796 1.5269735\nAAACGCACTGGTAC-1               1 group1     36.19972 0.7896914\n\n\nIs there a quicker way to perform the same job?\n\n# Add a column to metadata with the [[ operator\npbmc$new.col &lt;- colMeans(pbmc@assays$RNA$data[genes.pc1, ], na.rm = TRUE)\nhead(pbmc@meta.data)\n\n                 orig.ident nCount_RNA nFeature_RNA percent.mt RNA_snn_res.0.5\nAAACATACAACCAC-1     pbmc3k       2419          779  3.0177759               1\nAAACATTGAGCTAC-1     pbmc3k       4903         1352  3.7935958               3\nAAACATTGATCAGC-1     pbmc3k       3147         1129  0.8897363               1\nAAACCGTGCTTCCG-1     pbmc3k       2639          960  1.7430845               5\nAAACCGTGTATGCG-1     pbmc3k        980          521  1.2244898               6\nAAACGCACTGGTAC-1     pbmc3k       2163          781  1.6643551               1\n                 seurat_clusters groups percent.ribo score.pc1   new.col\nAAACATACAACCAC-1               1 group2     43.69574 0.7848191 0.7848191\nAAACATTGAGCTAC-1               3 group1     42.40261 1.0573239 1.0573239\nAAACATTGATCAGC-1               1 group1     31.68097 0.9407809 0.9407809\nAAACCGTGCTTCCG-1               5 group1     24.25161 4.2034002 4.2034002\nAAACCGTGTATGCG-1               6 group1     14.89796 1.5269735 1.5269735\nAAACGCACTGGTAC-1               1 group1     36.19972 0.7896914 0.7896914\n\n\nCan you check that the two columns are identical?\n\nidentical(pbmc$score.pc1, pbmc$new.col)\n\n[1] TRUE\n\n\nCan you check the distribution of the PC1 score?\n\nFeaturePlot(object = pbmc, features = c(\"CST3\", \"score.pc1\"), reduction = \"umap\")\n\n\n\n\n\n\n\n\n\nsaveRDS(pbmc, file = \"../pbmc_tutorial.rds\")"
  },
  {
    "objectID": "IntroGR/pages/GRanges_gtf.html",
    "href": "IntroGR/pages/GRanges_gtf.html",
    "title": "GRanges",
    "section": "",
    "text": "GRanges\nThe GenomicRanges package serves as the foundation for representing genomic locations. We will use the operations implemented in the GenomicRanges and related packages to run jobs typically performed in the context of a high throughput sequence analysis.\nObjectives"
  },
  {
    "objectID": "IntroGR/pages/GRanges_gtf.html#install-and-load",
    "href": "IntroGR/pages/GRanges_gtf.html#install-and-load",
    "title": "GRanges",
    "section": "Install and load",
    "text": "Install and load\n\nif (!require(\"BiocManager\"))\n    install.packages(\"BiocManager\")\n\nif (!require(\"GenomicRanges\"))\n  BiocManager::install(\"GenomicRanges\")\n\n\nlibrary(GenomicRanges)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(curl)\n#library(plyranges)"
  },
  {
    "objectID": "IntroGR/pages/GRanges_gtf.html#the-genomic-range-object",
    "href": "IntroGR/pages/GRanges_gtf.html#the-genomic-range-object",
    "title": "GRanges",
    "section": "The Genomic Range Object",
    "text": "The Genomic Range Object\nThe GRanges class defines a set of genomic ranges, each characterized by a single start and end position on the genome. It is commonly used to store the locations of genomic features such as contiguous binding sites, transcripts, and exons. GRanges objects can be created using the GRanges constructor function. For instance:\n\ngr &lt;- GRanges(\n    seqnames = Rle(c(\"chr1\", \"chr2\", \"chr1\", \"chr3\"), c(1, 3, 2, 4)),\n    ranges = IRanges(start = 101:110, end = 111:120, names = head(letters, 10)),\n    strand = Rle(strand(c(\"-\", \"+\", \"*\", \"+\", \"-\")), c(1, 2, 2, 3, 2)), # strand --&gt; without double quotes\n    score = 1:10,\n    GC = seq(1, 0, length=10))\ngr\n\nGRanges object with 10 ranges and 2 metadata columns:\n    seqnames    ranges strand |     score        GC\n       &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt;\n  a     chr1   101-111      - |         1  1.000000\n  b     chr2   102-112      + |         2  0.888889\n  c     chr2   103-113      + |         3  0.777778\n  d     chr2   104-114      * |         4  0.666667\n  e     chr1   105-115      * |         5  0.555556\n  f     chr1   106-116      + |         6  0.444444\n  g     chr3   107-117      + |         7  0.333333\n  h     chr3   108-118      + |         8  0.222222\n  i     chr3   109-119      - |         9  0.111111\n  j     chr3   110-120      - |        10  0.000000\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n\n\nThe output of the GRanges displays information in two sections separated by a | symbol. Genomic coordinates (including seqnames, ranges, strand, names) appear on the left-hand side, while metadata columns (annotations) are shown on the right. In the above example, the metadata includes score and GC content, although the metadata section of a GRanges object can store a wide variety of information.\n\nclass(gr)\n\n[1] \"GRanges\"\nattr(,\"package\")\n[1] \"GenomicRanges\"\n\nlength(gr)\n\n[1] 10\n\n\nAn Rle (run-length-encoded) vector is a specific representation of a vector. For more information have a look at: https://kasperdanielhansen.github.io/genbioconductor/html/GenomicRanges_Rle.html. The IRanges function defines interval ranges.\n\nExtract idividual components of the GR object\nThe genomic coordinate components of a GRanges object can be accessed using the seqnames, names, and strand functions.\n\n# Extract chromosome names\nseqnames(gr)\n\nfactor-Rle of length 10 with 4 runs\n  Lengths:    1    3    2    4\n  Values : chr1 chr2 chr1 chr3\nLevels(3): chr1 chr2 chr3\n\n\n\n# Extract the strand\nstrand(gr)\n\nfactor-Rle of length 10 with 5 runs\n  Lengths: 1 2 2 3 2\n  Values : - + * + -\nLevels(3): + - *\n\n\n\n# Extract the names\nnames(gr)\n\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\"\n\n\n\n# Extract the start position\nstart(gr)\n\n [1] 101 102 103 104 105 106 107 108 109 110\n\n\n\n\nBasic interval operations\nThe genomic ranges can be extracted without corresponding metadata with ranges or granges\n\nranges(gr)\n\nIRanges object with 10 ranges and 0 metadata columns:\n        start       end     width\n    &lt;integer&gt; &lt;integer&gt; &lt;integer&gt;\n  a       101       111        11\n  b       102       112        11\n  c       103       113        11\n  d       104       114        11\n  e       105       115        11\n  f       106       116        11\n  g       107       117        11\n  h       108       118        11\n  i       109       119        11\n  j       110       120        11\n\n\n\n# Extract genomic ranges without annotations\ngranges(gr)\n\nGRanges object with 10 ranges and 0 metadata columns:\n    seqnames    ranges strand\n       &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt;\n  a     chr1   101-111      -\n  b     chr2   102-112      +\n  c     chr2   103-113      +\n  d     chr2   104-114      *\n  e     chr1   105-115      *\n  f     chr1   106-116      +\n  g     chr3   107-117      +\n  h     chr3   108-118      +\n  i     chr3   109-119      -\n  j     chr3   110-120      -\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n\n\nWhat is the length of the genomic regions? One might want to plot the peak length distribution for called peaks. GRanges can provide this in one function.\n\n# Extract the width\nwidth(gr)\n\n [1] 11 11 11 11 11 11 11 11 11 11\n\n\n\n\nExtracting annotations\n\n# Extract annotations\nmcols(gr)\n\nDataFrame with 10 rows and 2 columns\n      score        GC\n  &lt;integer&gt; &lt;numeric&gt;\na         1  1.000000\nb         2  0.888889\nc         3  0.777778\nd         4  0.666667\ne         5  0.555556\nf         6  0.444444\ng         7  0.333333\nh         8  0.222222\ni         9  0.111111\nj        10  0.000000\n\nmcols(gr)$GC\n\n [1] 1.0000000 0.8888889 0.7777778 0.6666667 0.5555556 0.4444444 0.3333333\n [8] 0.2222222 0.1111111 0.0000000\n\n\n\n# Reverse GRanges\n#rev(gr)\n\n\n\nSubset GRanges objects\nStandard subsetting methods similar to R vectors and lists can be used to subset GRanges objects.\nSubset specific intervals\n\ngr[c('a','d')]\n\nGRanges object with 2 ranges and 2 metadata columns:\n    seqnames    ranges strand |     score        GC\n       &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt;\n  a     chr1   101-111      - |         1  1.000000\n  d     chr2   104-114      * |         4  0.666667\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n\ngr[2:3]\n\nGRanges object with 2 ranges and 2 metadata columns:\n    seqnames    ranges strand |     score        GC\n       &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt;\n  b     chr2   102-112      + |         2  0.888889\n  c     chr2   103-113      + |         3  0.777778\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n\n\nSelect and filter specific metadata\n\ngr[2:3, c('GC','score')]\n\nGRanges object with 2 ranges and 2 metadata columns:\n    seqnames    ranges strand |        GC     score\n       &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt; | &lt;numeric&gt; &lt;integer&gt;\n  b     chr2   102-112      + |  0.888889         2\n  c     chr2   103-113      + |  0.777778         3\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n\n\n\ngr[gr$GC&gt;0.7]\n\nGRanges object with 3 ranges and 2 metadata columns:\n    seqnames    ranges strand |     score        GC\n       &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt;\n  a     chr1   101-111      - |         1  1.000000\n  b     chr2   102-112      + |         2  0.888889\n  c     chr2   103-113      + |         3  0.777778\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths"
  },
  {
    "objectID": "IntroGR/pages/GRanges_gtf.html#plyranges",
    "href": "IntroGR/pages/GRanges_gtf.html#plyranges",
    "title": "GRanges",
    "section": "plyranges",
    "text": "plyranges\nCan we use dplyr functions with GRanges objects?\n\ngr %&gt;% select(GC)\n\nIn general, dplyr functions do not directly apply on a GRanges object, because GRanges is a special Bioconductor object and not a standard data frame or tibble. One option is to convert a GRanges object to a tibble or data.frame using as.data.frame() or as_tibble(), and then use dplyr functions like select(), filter(), mutate(), etc. Following manipulation, it can be converted back to a GRanges object if needed.\nmakeGRangesFromDataFrame uses as input a data-frame-like object and automatically finds the columns that describe genomic ranges. It then returns them as a GRanges object. A number of arguments control the behaviour of the function and modify the output GRange object.\nWhat is the purpose of the keep.extra.columns option?\n\n# Convert to a dataframe, filter with dplyr, and re-convert to a GRanges object\ngr_df &lt;- as.data.frame(gr)\ngr_df &lt;- gr_df %&gt;% filter(GC&gt;0.7) %&gt;% select(-strand)\n\n# Convert data.frame to GRanges object \nmakeGRangesFromDataFrame(gr_df, keep.extra.columns = TRUE)\n\nGRanges object with 3 ranges and 2 metadata columns:\n    seqnames    ranges strand |     score        GC\n       &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt;\n  a     chr1   101-111      * |         1  1.000000\n  b     chr2   102-112      * |         2  0.888889\n  c     chr2   103-113      * |         3  0.777778\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n\n\nAlternatively, one can use plyranges, a Bioconductor package that extends dplyr-style syntax directly to GRanges objects.\n\n#BiocManager::install(\"plyranges\")\n\n\nlibrary(plyranges)\n\n\nAttaching package: 'plyranges'\n\n\nThe following objects are masked from 'package:dplyr':\n\n    between, n, n_distinct\n\n\nThe following object is masked from 'package:IRanges':\n\n    slice\n\n\nThe following object is masked from 'package:stats':\n\n    filter\n\ngr %&gt;% filter(GC&gt;0.7)\n\nGRanges object with 3 ranges and 2 metadata columns:\n    seqnames    ranges strand |     score        GC\n       &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt;\n  a     chr1   101-111      - |         1  1.000000\n  b     chr2   102-112      + |         2  0.888889\n  c     chr2   103-113      + |         3  0.777778\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n\n\n\n# Convert GRanges object to a dataframe \ngr %&gt;% as.data.frame() %&gt;% head()\n\n  seqnames start end width strand score        GC\na     chr1   101 111    11      -     1 1.0000000\nb     chr2   102 112    11      +     2 0.8888889\nc     chr2   103 113    11      +     3 0.7777778\nd     chr2   104 114    11      *     4 0.6666667\ne     chr1   105 115    11      *     5 0.5555556\nf     chr1   106 116    11      +     6 0.4444444\n\n\n\nNot all dplyr functions are compatible with GRanges object. In some cases you need to convert to a tibble and then back to a GR object."
  },
  {
    "objectID": "IntroGR/pages/GRanges_gtf.html#import-gtf-for-homo-sapiens",
    "href": "IntroGR/pages/GRanges_gtf.html#import-gtf-for-homo-sapiens",
    "title": "GRanges",
    "section": "Import GTF for Homo sapiens",
    "text": "Import GTF for Homo sapiens\nGRanges provides a flexible framework for importing, inspecting, and processing GTF (Gene Transfer Format) files. Here, we will retrieve a GTF file containing genomic annotations for Homo sapiens from the Ensembl FTP server. We will use the import function from the rtracklayer package to fetch the gtf file.\n\n# Import library\nlibrary(rtracklayer)\n\n\n# Define the FTP URL\nftp_url = \"ftp://ftp.ensembl.org/pub/release-106/gtf/homo_sapiens/Homo_sapiens.GRCh38.106.chr.gtf.gz\"\n\n\n# Import gtf as GRange object\noptions(timeout = 1000)\ngtf &lt;- rtracklayer::import(ftp_url)\n\n\n# View GRanges \ngtf %&gt;% head()\n\nGRanges object with 6 ranges and 22 metadata columns:\n      seqnames          ranges strand |         source        type     score\n         &lt;Rle&gt;       &lt;IRanges&gt;  &lt;Rle&gt; |       &lt;factor&gt;    &lt;factor&gt; &lt;numeric&gt;\n  [1]        1 1211340-1214153      - | ensembl_havana gene               NA\n  [2]        1 1211340-1214153      - | ensembl_havana transcript         NA\n  [3]        1 1213983-1214153      - | ensembl_havana exon               NA\n  [4]        1 1213983-1214127      - | ensembl_havana CDS                NA\n  [5]        1 1214125-1214127      - | ensembl_havana start_codon        NA\n  [6]        1 1213663-1213785      - | ensembl_havana exon               NA\n          phase         gene_id gene_version   gene_name    gene_source\n      &lt;integer&gt;     &lt;character&gt;  &lt;character&gt; &lt;character&gt;    &lt;character&gt;\n  [1]      &lt;NA&gt; ENSG00000186827           11     TNFRSF4 ensembl_havana\n  [2]      &lt;NA&gt; ENSG00000186827           11     TNFRSF4 ensembl_havana\n  [3]      &lt;NA&gt; ENSG00000186827           11     TNFRSF4 ensembl_havana\n  [4]         0 ENSG00000186827           11     TNFRSF4 ensembl_havana\n  [5]         0 ENSG00000186827           11     TNFRSF4 ensembl_havana\n  [6]      &lt;NA&gt; ENSG00000186827           11     TNFRSF4 ensembl_havana\n        gene_biotype   transcript_id transcript_version transcript_name\n         &lt;character&gt;     &lt;character&gt;        &lt;character&gt;     &lt;character&gt;\n  [1] protein_coding            &lt;NA&gt;               &lt;NA&gt;            &lt;NA&gt;\n  [2] protein_coding ENST00000379236                  4     TNFRSF4-201\n  [3] protein_coding ENST00000379236                  4     TNFRSF4-201\n  [4] protein_coding ENST00000379236                  4     TNFRSF4-201\n  [5] protein_coding ENST00000379236                  4     TNFRSF4-201\n  [6] protein_coding ENST00000379236                  4     TNFRSF4-201\n      transcript_source transcript_biotype         tag     ccds_id\n            &lt;character&gt;        &lt;character&gt; &lt;character&gt; &lt;character&gt;\n  [1]              &lt;NA&gt;               &lt;NA&gt;        &lt;NA&gt;        &lt;NA&gt;\n  [2]    ensembl_havana     protein_coding       basic      CCDS11\n  [3]    ensembl_havana     protein_coding       basic      CCDS11\n  [4]    ensembl_havana     protein_coding       basic      CCDS11\n  [5]    ensembl_havana     protein_coding       basic      CCDS11\n  [6]    ensembl_havana     protein_coding       basic      CCDS11\n      transcript_support_level exon_number         exon_id exon_version\n                   &lt;character&gt; &lt;character&gt;     &lt;character&gt;  &lt;character&gt;\n  [1]                     &lt;NA&gt;        &lt;NA&gt;            &lt;NA&gt;         &lt;NA&gt;\n  [2]   1 (assigned to previ..        &lt;NA&gt;            &lt;NA&gt;         &lt;NA&gt;\n  [3]   1 (assigned to previ..           1 ENSE00001832731            2\n  [4]   1 (assigned to previ..           1            &lt;NA&gt;         &lt;NA&gt;\n  [5]   1 (assigned to previ..           1            &lt;NA&gt;         &lt;NA&gt;\n  [6]   1 (assigned to previ..           2 ENSE00001333068            1\n           protein_id protein_version\n          &lt;character&gt;     &lt;character&gt;\n  [1]            &lt;NA&gt;            &lt;NA&gt;\n  [2]            &lt;NA&gt;            &lt;NA&gt;\n  [3]            &lt;NA&gt;            &lt;NA&gt;\n  [4] ENSP00000368538               3\n  [5]            &lt;NA&gt;            &lt;NA&gt;\n  [6]            &lt;NA&gt;            &lt;NA&gt;\n  -------\n  seqinfo: 25 sequences from an unspecified genome; no seqlengths\n\n\n\nInspect the GTF file\nCheck the metadata information contained in the GTF file\n\n# Check the metadata information\nmcols(gtf) %&gt;% names()\n\n [1] \"source\"                   \"type\"                    \n [3] \"score\"                    \"phase\"                   \n [5] \"gene_id\"                  \"gene_version\"            \n [7] \"gene_name\"                \"gene_source\"             \n [9] \"gene_biotype\"             \"transcript_id\"           \n[11] \"transcript_version\"       \"transcript_name\"         \n[13] \"transcript_source\"        \"transcript_biotype\"      \n[15] \"tag\"                      \"ccds_id\"                 \n[17] \"transcript_support_level\" \"exon_number\"             \n[19] \"exon_id\"                  \"exon_version\"            \n[21] \"protein_id\"               \"protein_version\"         \n\n\nNotice that GRanges was able to properly tabulate the information contained in the 9th column of the GTF file. This wouldn’t be as efficient using the read.table() function.\nWhat are the different type of intervals?\n\n# Inspect the levels in the `type` column\n#gtf %&gt;% count(type)\ngtf %&gt;%\n  group_by(type) %&gt;%\n  summarise(n = n())\n\nDataFrame with 9 rows and 2 columns\n             type         n\n         &lt;factor&gt; &lt;integer&gt;\n1 gene                61498\n2 transcript         246452\n3 exon              1572337\n4 CDS                851032\n5 start_codon         95255\n6 stop_codon          88853\n7 five_prime_utr     168139\n8 three_prime_utr    195144\n9 Selenocysteine        119\n\n\nHow many unique protein-coding genes there are in the gtf?\n\n# Using dplyr with additionally removing duplicate genes\npcg &lt;- gtf %&gt;% \n      as_tibble() %&gt;%\n      filter(type=='gene' & gene_biotype=='protein_coding' & !is.na(gene_name)) %&gt;%\n      distinct(gene_name, .keep_all = TRUE) %&gt;%\n      makeGRangesFromDataFrame(keep.extra.columns = TRUE)\n\nlength(pcg)\n\n[1] 19355\n\nclass(pcg)\n\n[1] \"GRanges\"\nattr(,\"package\")\n[1] \"GenomicRanges\"\n\n\n\n\nDrawing plots of metadata information\nTabulate the number of genes per chromosome\n\nseqnames(pcg) %&gt;% table()\n\n.\n   1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16 \n2005 1220 1043  741  865 1011  894  668  750  713 1283  999  314  591  575  816 \n  17   18   19   20   21   22    X    Y   MT \n1146  263 1389  529  215  427  839   46   13 \n\n\nPlot the number of unique protein-coding genes per chromosome. In this case, we do not filter for protein-coding genes.\n\n# PLot by chromosome\noptions(repr.plot.width=28, repr.plot.height=4)\n\npcg %&gt;% \n    as.data.frame() %&gt;% \n    #group_by(seqnames, gene_biotype) %&gt;%\n    summarize(.by=c(seqnames, gene_biotype), count = n()) %&gt;%\n    ggplot(aes(x = seqnames, y = count, fill=gene_biotype)) +\n      geom_bar(stat = 'identity', position = 'dodge') +\n      theme_classic() +\n        theme(axis.title=element_text(size=14), axis.text = element_text(size=14),\n        legend.title=element_blank(), legend.text = element_text(size=14),      \n        axis.text.x = element_text(angle = 45, vjust=1, hjust = 1))\n\n\n\n\n\n\n\n\nPlot the different genes types per chromosome\n\n# PLot by chromosome\n\ngtf %&gt;%\n    as.data.frame() %&gt;% \n    filter(type=='gene' & !is.na(gene_name)) %&gt;%\n    group_by(seqnames, gene_biotype) %&gt;%\n    summarize(count = n()) %&gt;%\n    ggplot(aes(x = seqnames, y = count, fill=gene_biotype)) +\n      geom_bar(stat = 'identity', position = 'dodge') +\n      theme_classic() +\n        theme(axis.title=element_text(size=14), axis.text = element_text(size=14),\n        legend.title=element_blank(), legend.text = element_text(size=14), legend.position = 'bottom',     \n        axis.text.x = element_text(angle = 45, vjust=1, hjust = 1))\n\n`summarise()` has grouped output by 'seqnames'. You can override using the\n`.groups` argument.\n\n\n\n\n\n\n\n\n\nPlot the distribution across chromosomes per each gene type. Which gene type is the most abundant?\n\noptions(repr.plot.width=20, repr.plot.height=8)\n\ngtf %&gt;%\n    as.data.frame() %&gt;%\n    filter(type=='gene' & !is.na(gene_name)) %&gt;%\n    group_by(seqnames, gene_biotype) %&gt;%\n    summarize(count = n()) %&gt;%\n    ggplot(aes(x = gene_biotype, y = count, fill=seqnames)) +\n      geom_bar(stat = 'identity', position = 'dodge') +\n      theme_classic() +\n        theme(axis.title=element_text(size=14), axis.text = element_text(size=14),\n        legend.title=element_blank(), legend.text = element_text(size=14),      \n        axis.text.x = element_text(angle = 45, vjust=1, hjust = 1))\n\n`summarise()` has grouped output by 'seqnames'. You can override using the\n`.groups` argument."
  },
  {
    "objectID": "IntroGR/pages/GRanges_gtf.html#defining-the-tss-of-transcripts",
    "href": "IntroGR/pages/GRanges_gtf.html#defining-the-tss-of-transcripts",
    "title": "GRanges",
    "section": "Defining the TSS of transcripts",
    "text": "Defining the TSS of transcripts\nIn genomic analyses, we often need to generate a file containing transcription start site (TSS) positions or windows surrounding the TSS. This regions are important for defining promoter areas, where the regulation of gene expression primarily occurs. TSS-centered regions are also crucial for performing downstream analyses, e.g. motif discovery for transcription factors, or assessing the overlap with accessible regions (derived from ATAC-seq data) or regions of histone mark occupancy and transcription factor binding (ChIP-seq data).\nGTF files are the primary source from where we can extract TSS positions. Here, we will identify the TSS of transcripts and create a window around them that spans 1000 bases upstream and 500 bases downstream of the TSS.\nFirst we will retrieve all transcripts. We will filter for ensembl_havana annotated transcripts. HAVANA stands for Human And Vertebrate Analysis and Annotation. These are manually curated annotations (Wellcome Sanger Institute) integrated with the automatic annotation of Ensembl.\n\ntx &lt;- gtf %&gt;% \n    as_tibble() %&gt;%\n    filter(type == \"transcript\" & source == \"ensembl_havana\" & !is.na(transcript_name)) %&gt;%\n    #distinct(transcript_name, .keep_all = TRUE) %&gt;%\n    makeGRangesFromDataFrame(, keep.extra.columns = TRUE)\n\nlength(tx)\n\n[1] 26624\n\nhead(tx,2)\n\nGRanges object with 2 ranges and 22 metadata columns:\n      seqnames          ranges strand |         source       type     score\n         &lt;Rle&gt;       &lt;IRanges&gt;  &lt;Rle&gt; |       &lt;factor&gt;   &lt;factor&gt; &lt;numeric&gt;\n  [1]        1 1211340-1214153      - | ensembl_havana transcript        NA\n  [2]        1 1203508-1206571      - | ensembl_havana transcript        NA\n          phase         gene_id gene_version   gene_name    gene_source\n      &lt;integer&gt;     &lt;character&gt;  &lt;character&gt; &lt;character&gt;    &lt;character&gt;\n  [1]      &lt;NA&gt; ENSG00000186827           11     TNFRSF4 ensembl_havana\n  [2]      &lt;NA&gt; ENSG00000186891           14    TNFRSF18 ensembl_havana\n        gene_biotype   transcript_id transcript_version transcript_name\n         &lt;character&gt;     &lt;character&gt;        &lt;character&gt;     &lt;character&gt;\n  [1] protein_coding ENST00000379236                  4     TNFRSF4-201\n  [2] protein_coding ENST00000328596                 10    TNFRSF18-201\n      transcript_source transcript_biotype         tag     ccds_id\n            &lt;character&gt;        &lt;character&gt; &lt;character&gt; &lt;character&gt;\n  [1]    ensembl_havana     protein_coding       basic      CCDS11\n  [2]    ensembl_havana     protein_coding       basic       CCDS9\n      transcript_support_level exon_number     exon_id exon_version  protein_id\n                   &lt;character&gt; &lt;character&gt; &lt;character&gt;  &lt;character&gt; &lt;character&gt;\n  [1]   1 (assigned to previ..        &lt;NA&gt;        &lt;NA&gt;         &lt;NA&gt;        &lt;NA&gt;\n  [2]                        1        &lt;NA&gt;        &lt;NA&gt;         &lt;NA&gt;        &lt;NA&gt;\n      protein_version\n          &lt;character&gt;\n  [1]            &lt;NA&gt;\n  [2]            &lt;NA&gt;\n  -------\n  seqinfo: 25 sequences from an unspecified genome; no seqlengths\n\n\nTo create TSS genomic coordinates, we will define TSS as start position for the ‘+’ strand and end position for the ‘-’ strand. Here, we use the ifelse() function to define the position: if strand is positive, then start equals to tx start position, otherwise (when strand is not positive) start equals to tx end position.\n\n# Define TSS as start position for '+' strand and end position for '-' strand\ntss &lt;- GRanges(\n  seqnames = seqnames(tx),\n  ranges = IRanges(\n    start = ifelse(strand(tx) == \"+\", start(tx) , end(tx)),\n    end = ifelse(strand(tx) == \"+\", start(tx), end(tx))\n  ),\n  strand = strand(tx),\n  gene_name = tx$gene_name,  \n  gene_id = tx$gene_id \n)\n\nlength(tss)\n\n[1] 26624\n\nhead(tss, 4)\n\nGRanges object with 4 ranges and 2 metadata columns:\n      seqnames    ranges strand |   gene_name         gene_id\n         &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt; | &lt;character&gt;     &lt;character&gt;\n  [1]        1   1214153      - |     TNFRSF4 ENSG00000186827\n  [2]        1   1206571      - |    TNFRSF18 ENSG00000186891\n  [3]        1   1206592      - |    TNFRSF18 ENSG00000186891\n  [4]        1   1471765      + |      ATAD3B ENSG00000160072\n  -------\n  seqinfo: 25 sequences from an unspecified genome; no seqlengths\n\n\nExport the file with TSS genomic positions in BED format.\n\nexport(tss, \"../results/TSS.bed\", format = \"BED\")\n\nGRanges has dedicated method for doing the same job, called resize(). Let’s use the resize method to define the TSS\n\n# Alternative way to define TSS with the resize method\n\ntss.2 &lt;- gtf %&gt;% .[mcols(.)$type=='transcript'] %&gt;%\n                 .[mcols(.)$source=='ensembl_havana' & !is.na(mcols(.)$transcript_name)] %&gt;%\n                  resize(., 1) %&gt;%\n                  .[,c('gene_name','gene_id')] \n\nexport(tss.2, \"../results/TSS_v2.bed\", format = \"BED\")\nlength(tss.2)\n\n[1] 26624\n\nhead(tss.2)\n\nGRanges object with 6 ranges and 2 metadata columns:\n      seqnames    ranges strand |   gene_name         gene_id\n         &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt; | &lt;character&gt;     &lt;character&gt;\n  [1]        1   1214153      - |     TNFRSF4 ENSG00000186827\n  [2]        1   1206571      - |    TNFRSF18 ENSG00000186891\n  [3]        1   1206592      - |    TNFRSF18 ENSG00000186891\n  [4]        1   1471765      + |      ATAD3B ENSG00000160072\n  [5]        1   3069203      + |      PRDM16 ENSG00000142611\n  [6]        1   1307930      - |       ACAP3 ENSG00000131584\n  -------\n  seqinfo: 25 sequences from an unspecified genome; no seqlengths\n\n\nVerify that we got the same results\n\nidentical(tss, tss.2)\n\n[1] TRUE\n\n\nTry to define a window spanning the TSS 1000 bases upstream and 500 bases downstream. The upstream and downstream arguments define the number of nucleotides in the 5’ and 3’ direction, respectively.\n\n# Define a 100 bp window around the TSS\n\ntss_window &lt;- GRanges(\n  seqnames = seqnames(tss),\n  ranges = IRanges(\n    start = pmax(start(tss) - 1000, 1),  # Ensures start position is &gt;= 1. Returns the maximum value. \n    end = end(tss) + 500\n    ),\n  #strand = strand(tss)\n  gene_name = tx$gene_name,  \n  gene_id = tx$gene_id \n)\n\n# View result\nhead(tss_window, 4)\n\nGRanges object with 4 ranges and 2 metadata columns:\n      seqnames          ranges strand |   gene_name         gene_id\n         &lt;Rle&gt;       &lt;IRanges&gt;  &lt;Rle&gt; | &lt;character&gt;     &lt;character&gt;\n  [1]        1 1213153-1214653      * |     TNFRSF4 ENSG00000186827\n  [2]        1 1205571-1207071      * |    TNFRSF18 ENSG00000186891\n  [3]        1 1205592-1207092      * |    TNFRSF18 ENSG00000186891\n  [4]        1 1470765-1472265      * |      ATAD3B ENSG00000160072\n  -------\n  seqinfo: 25 sequences from an unspecified genome; no seqlengths\n\n\nWe can use the intra range transformation promoter() function of GRanges to do the same job. The output range is defined as\n(start(x) - upstream) to (start(x) + downstream - 1)\n  \nfor ranges on the + or * strand, and as\n(end(x) - downstream + 1) to (end(x) + upstream)\n  \nfor ranges on the - strand\n\ntss_window &lt;- promoters(tx, upstream=1000, downstream=500) %&gt;% .[,c('gene_name')]\n#export(tss_window, \"../results/TSS_window.bed\", format='BED')\ntss_window %&gt;% head(4)\n\nGRanges object with 4 ranges and 1 metadata column:\n      seqnames          ranges strand |   gene_name\n         &lt;Rle&gt;       &lt;IRanges&gt;  &lt;Rle&gt; | &lt;character&gt;\n  [1]        1 1213654-1215153      - |     TNFRSF4\n  [2]        1 1206072-1207571      - |    TNFRSF18\n  [3]        1 1206093-1207592      - |    TNFRSF18\n  [4]        1 1470765-1472264      + |      ATAD3B\n  -------\n  seqinfo: 25 sequences from an unspecified genome; no seqlengths"
  },
  {
    "objectID": "IntroGR/pages/GRanges_gtf.html#intersect-with-tf-bound-regions",
    "href": "IntroGR/pages/GRanges_gtf.html#intersect-with-tf-bound-regions",
    "title": "GRanges",
    "section": "Intersect with TF-bound regions",
    "text": "Intersect with TF-bound regions\nOne common question in the analysis of genomic intervals is what are the genes regulated by various trascription factors, or other members of the transcriptional machinery. In that case, we might want to compare the TSS intervals of genes to regions bound by a transcription factor.\nWe will determine the overlap between genomic regions bound by BATF, a pioneer transcription factor, and promoter intervals to identify genes potentially regulated by BATF. The BATF genomic regions derive from an experiment where naive CD4+ T cells isolated from human umbilical cord blood were in vitro polarized to Th17-fate for 72h and further subjected to BATF ChIP analysis. Genome-wide ChIP-seq reads were aligned to the hg38 genome assembly. The data is deposited in the public repository Gene Expression Omnibus (GEO) with accession id GSE174810. The latter is a SubSeries which is is part of SuperSeries GSE176065.\n[GEO]https://www.ncbi.nlm.nih.gov/geo/\nGSE174810: Genome-wide binding sites of FOSL1, FOSL2 and BATF in human Th17 cells [ChIP-seq]\n\n\n\n\nRetrieve data from GEO\nWe will fetch the supplementary files with the GEOquery function getGEOSuppFiles(). This will download the files in a directory named according to the GEO accession id. We can then untar/unzip the file and import the files we need. We will try different ways to achieve this:\ngetGEO() is the main user-level function in the GEOquery package. For more information, check out the package vignette GEOquery.\n\nlibrary(GEOquery)\n\nLoading required package: Biobase\n\n\nWelcome to Bioconductor\n\n    Vignettes contain introductory material; view with\n    'browseVignettes()'. To cite Bioconductor, see\n    'citation(\"Biobase\")', and for packages 'citation(\"pkgname\")'.\n\n\nSetting options('download.file.method.GEOquery'='auto')\n\n\nSetting options('GEOquery.inmemory.gpl'=FALSE)\n\n\n\nDownload supplementary files\n\nCheck the path to the current directory in order to understand where the file is downloaded.\n\ngetwd()\n\nDownload data from a GEO\n\n# Download data from a GEO and list files\n#setwd('../')\ngetGEOSuppFiles(\"GSE174810\")\n\nCheck that the tar file has been downloaded\n\nlist.files('../GSE174810/')\n\n[1] \"BATF_peaks.narrowPeak.gz\" \"GSE174810_RAW\"           \n[3] \"GSE174810_RAW.tar\"       \n\n\nCheck the list of files in the tar\n\nuntar(\"GSE174810/GSE174810_RAW.tar\", list = TRUE)\n\nTo untar directly from R we can use the built-in untar() function.\n\nuntar(\"../GSE174810/GSE174810_RAW.tar\", exdir = \"../GSE174810/GSE174810_RAW\")\n\nList the supplementary files\n\nlist.files('../GSE174810/GSE174810_RAW/')\n\n[1] \"GSM5328649_BATF_R1_peaks.narrowPeak.gz\"      \n[2] \"GSM5328651_BATF_R3_peaks.narrowPeak.gz\"      \n[3] \"GSM5328653_FOSL1_C-12_R1_peaks.narrowPeak.gz\"\n[4] \"GSM5328655_FOSL1_C-12_R2_peaks.narrowPeak.gz\"\n[5] \"GSM5328657_FOSL2_R1_peaks.narrowPeak.gz\"     \n[6] \"GSM5328659_FOSL2_R2_peaks.narrowPeak.gz\"     \n\n\nImport the file of interest, e.g. BATF_R1_peaks, by providing the connection con from which data is loaded.\n\nlibrary(rtracklayer)\n# R.utils::gunzip(\"../GSE174810/GSE174810_RAW/GSM5328649_BATF_R1_peaks.narrowPeak.gz\", \n#                 overwrite = TRUE)\n\nfile_path &lt;- \"../GSE174810/GSE174810_RAW/GSM5328649_BATF_R1_peaks.narrowPeak.gz\"\n\n#Does the file exist?\nfile.exists(file_path)\n\n[1] TRUE\n\n\n\noptions(timeout = 1000)\nbatf &lt;- import(con=file_path, format = \"narrowPeak\")\n#dim(bed)\nbatf %&gt;% head(2)\n\nGRanges object with 2 ranges and 6 metadata columns:\n      seqnames          ranges strand |           name     score signalValue\n         &lt;Rle&gt;       &lt;IRanges&gt;  &lt;Rle&gt; |    &lt;character&gt; &lt;numeric&gt;   &lt;numeric&gt;\n  [1]     chr1   992366-992706      * | BATF_R1_peak_1       491    10.86899\n  [2]     chr1 1013033-1013271      * | BATF_R1_peak_2        81     5.07551\n         pValue    qValue      peak\n      &lt;numeric&gt; &lt;numeric&gt; &lt;integer&gt;\n  [1]   52.8283  49.18042       180\n  [2]   10.9246   8.12685       170\n  -------\n  seqinfo: 33 sequences from an unspecified genome; no seqlengths\n\n\n\nRetrieve the file from GEO providing a URL.\n\n\n# Define URL\nbatf_url &lt;- \"https://ftp.ncbi.nlm.nih.gov/geo/samples/GSM5328nnn/GSM5328649/suppl/GSM5328649%5FBATF%5FR1%5Fpeaks%2EnarrowPeak%2Egz\"\n\n\n# error when rtracklayer::import is used directly on a remote .gz file\n\n# Download first\ndestfile &lt;- \"../GSE174810/BATF_peaks.narrowPeak.gz\"\ndownload.file(batf_url, destfile = destfile)\n\n# Then import it\nbatf &lt;- import(con = destfile, format = \"narrowPeak\")\nbatf %&gt;% head()\n\nGRanges object with 6 ranges and 6 metadata columns:\n      seqnames          ranges strand |           name     score signalValue\n         &lt;Rle&gt;       &lt;IRanges&gt;  &lt;Rle&gt; |    &lt;character&gt; &lt;numeric&gt;   &lt;numeric&gt;\n  [1]     chr1   992366-992706      * | BATF_R1_peak_1       491    10.86899\n  [2]     chr1 1013033-1013271      * | BATF_R1_peak_2        81     5.07551\n  [3]     chr1 1064103-1064463      * | BATF_R1_peak_3       515    16.40878\n  [4]     chr1 1098903-1099465      * | BATF_R1_peak_4        39     3.95218\n  [5]     chr1 1208075-1208187      * | BATF_R1_peak_5        36     3.40441\n  [6]     chr1 1217964-1218107      * | BATF_R1_peak_6        53     4.60597\n         pValue    qValue      peak\n      &lt;numeric&gt; &lt;numeric&gt; &lt;integer&gt;\n  [1]  52.82834  49.18042       180\n  [2]  10.92463   8.12685       170\n  [3]  55.24189  51.56105       189\n  [4]   6.55161   3.96331       393\n  [5]   6.17971   3.61470        59\n  [6]   8.03364   5.36412        56\n  -------\n  seqinfo: 33 sequences from an unspecified genome; no seqlengths\n\n\n\nLet us check the length distribution of the intervals\n\n\nmean(width(batf))\n\n[1] 306.8564\n\n#mcols(batf)$width &lt;- width(batf)\n\nbatf %&gt;% \n  as.data.frame() %&gt;% \n  ggplot(aes(width)) + \n    geom_density() + \n    scale_x_continuous(trans='log2') +\n    geom_vline(xintercept=mean(width(batf)), color=\"red\", linewidth=0.1 ) +\n    theme_classic()\n\n\n\n\n\n\n\n# log2(width) returns log2 values on the x-axis, whilst scale_x_continuous() keeps the original values.\n\nCheck the seqnames. You will notice that it contains seqnames not present in the tss_window()\n\nseqnames(batf) %&gt;% table()\n\n.\n                   chr1                   chr10                   chr11 \n                   4462                    2267                    1958 \n                  chr12                   chr13                   chr14 \n                   2522                    1347                    1634 \n                  chr15                   chr16                   chr17 \n                   1450                    1144                    1652 \nchr17_GL000205v2_random                   chr18                   chr19 \n                      1                     915                     950 \n chr1_KI270706v1_random                    chr2                   chr20 \n                      1                    4209                     949 \n                  chr21                   chr22 chr22_KI270733v1_random \n                    622                     592                       1 \n                   chr3                    chr4                    chr5 \n                   3375                    2256                    2491 \n                   chr6                    chr7                    chr8 \n                   3390                    2148                    2218 \n                   chr9        chrUn_GL000195v1        chrUn_GL000219v1 \n                   1625                       1                       2 \n       chrUn_GL000220v1        chrUn_KI270438v1        chrUn_KI270466v1 \n                      1                       1                       1 \n       chrUn_KI270467v1                    chrX                    chrY \n                      3                    1047                       8 \n\n\nFrom the UCSC site:\nChrN_random relates to sequence that is known to be in a particular chromosome, but could not be reliably ordered within the current sequence. ChrUn contains clone contigs that cannot be confidently placed on a specific chromosome. For the chrN_random and chrUn_random files, we essentially just concatenate together all the contigs into short pseudo-chromosomes. The coordinates of these are fairly arbitrary, although the relative positions of the coordinates are good within a contig. You can find more information about the data organization and format on the Data Organization and Format page.\nTo be able to intersect the two GRanges objects, the seqnames need to match. We need to modify the seqnames() of the batf GR object to match the levels of the tss_window GR object. To keep it simple, we will only change the seqnames for the autosomal chromosomes (1:22) plus chromosomes X and Y. It is also important to ensure that the genomic positions refer to the same genome assembly, in this case the human build 38!\n\n# Seqnames of tss_window\nseqnames(tss_window) %&gt;% table()\n\n.\n   1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16 \n2694 1761 1535 1031 1146 1365 1221  955 1004  968 1683 1470  419  842  834 1130 \n  17   18   19   20   21   22    X    Y   MT \n1592  403 1795  729  312  591 1071   73    0"
  },
  {
    "objectID": "IntroGR/pages/GRanges_gtf.html#convert-seqnames-of-batf-gr-object",
    "href": "IntroGR/pages/GRanges_gtf.html#convert-seqnames-of-batf-gr-object",
    "title": "GRanges",
    "section": "Convert seqnames of BATF GR object",
    "text": "Convert seqnames of BATF GR object\n\n# Modify seqnames\n#remove_seqnames &lt;- \"chrM|chrUn|chrEBV|random\"\n#batf &lt;- batf[!(grepl(remove_seqnames, seqnames(batf)) ) ]\n#batf &lt;- keepSeqlevels(batf, \n#           seqlevelsInUse(batf), \n#          pruning.mode=\"coarse\" #Remove the elements in x where the seqlevels to drop are in use.\n#          ) \n\nseqlevels(batf) &lt;- sub(\"^chr\", \"\", seqlevels(batf))\n\n\nseqnames(batf) %&gt;% table()\n\n.\n                   1                   10                   11 \n                4462                 2267                 1958 \n                  12                   13                   14 \n                2522                 1347                 1634 \n                  15                   16                   17 \n                1450                 1144                 1652 \n17_GL000205v2_random                   18                   19 \n                   1                  915                  950 \n 1_KI270706v1_random                    2                   20 \n                   1                 4209                  949 \n                  21                   22 22_KI270733v1_random \n                 622                  592                    1 \n                   3                    4                    5 \n                3375                 2256                 2491 \n                   6                    7                    8 \n                3390                 2148                 2218 \n                   9        Un_GL000195v1        Un_GL000219v1 \n                1625                    1                    2 \n       Un_GL000220v1        Un_KI270438v1        Un_KI270466v1 \n                   1                    1                    1 \n       Un_KI270467v1                    X                    Y \n                   3                 1047                    8 \n\n\nWe will use the subsetByOverlaps method of GRanges to extract the elements in the query (e.g. TSS) that overlap at least one element in the subject (e.g. batf).\n\noverlap &lt;- subsetByOverlaps(tss_window, batf)\n\nWarning in .merge_two_Seqinfo_objects(x, y): Each of the 2 combined objects has sequence levels not in the other:\n  - in 'x': MT\n  - in 'y': 17_GL000205v2_random, 1_KI270706v1_random, 22_KI270733v1_random, Un_GL000195v1, Un_GL000219v1, Un_GL000220v1, Un_KI270438v1, Un_KI270466v1, Un_KI270467v1\n  Make sure to always combine/compare objects based on the same reference\n  genome (use suppressWarnings() to suppress this warning).\n\noverlap\n\nGRanges object with 3888 ranges and 1 metadata column:\n         seqnames            ranges strand |   gene_name\n            &lt;Rle&gt;         &lt;IRanges&gt;  &lt;Rle&gt; | &lt;character&gt;\n     [1]        1 12617711-12619210      - |       DHRS3\n     [2]        1   8525440-8526939      - |        RERE\n     [3]        1   8423167-8424666      - |        RERE\n     [4]        1 11805191-11806690      + |       CLCN6\n     [5]        1   2526097-2527596      - |       PANK4\n     ...      ...               ...    ... .         ...\n  [3884]       21 46634642-46636141      + |       PRMT2\n  [3885]       21 46634653-46636152      + |       PRMT2\n  [3886]       21 46634681-46636180      + |       PRMT2\n  [3887]       21 33947926-33949425      + |   LINC00649\n  [3888]       21 46285384-46286883      + |        YBEY\n  -------\n  seqinfo: 25 sequences from an unspecified genome; no seqlengths\n\n\n\nCan you tell what the warning is about?\n\nNow we can retrieve the genes, whose promoter is bound by the BATF transcription factor.\n\ngenes &lt;- overlap$gene_name %&gt;% unique() %&gt;% sort()\nlength(genes)\n\n[1] 2709\n\nhead(genes)\n\n[1] \"AAAS\"  \"AAGAB\" \"AAK1\"  \"AAMP\"  \"AARS1\" \"ABCB1\""
  },
  {
    "objectID": "IntroGR/pages/GRanges_gtf.html#range-based-transformations-are-grouped-in-2-categories",
    "href": "IntroGR/pages/GRanges_gtf.html#range-based-transformations-are-grouped-in-2-categories",
    "title": "GRanges",
    "section": "Range-based transformations are grouped in 2 categories:",
    "text": "Range-based transformations are grouped in 2 categories:\n\nIntra range transformations (e.g. shift()) transform each range individually (and independently of the other ranges). They return an object parallel to the input object, that is, where the i-th range corresponds to the i-th range in the input. Those transformations are described in the intra-range-methods man page (see ?intra-range-methods).\nInter range transformations (e.g. reduce()) transform all the ranges together as a set to produce a new set of ranges. They return an object that is generally NOT parallel to the input object. Those transformations are described below.\n\n\nIntra-range functions\nOperate on each element of a GRanges object independently of the other ranges in the object.\nFor instance, the flank method allows you to generate regions flanking the existing ranges in a GRanges object in a strand dependent manner. To capture the 10 bases located upstream of these ranges:\n\ng &lt;- gr[1:3]\ng\n\nGRanges object with 3 ranges and 2 metadata columns:\n    seqnames    ranges strand |     score        GC\n       &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt;\n  a     chr1   101-111      - |         1  1.000000\n  b     chr2   102-112      + |         2  0.888889\n  c     chr2   103-113      + |         3  0.777778\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n\nflank(g, 10)\n\nGRanges object with 3 ranges and 2 metadata columns:\n    seqnames    ranges strand |     score        GC\n       &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt;\n  a     chr1   112-121      - |         1  1.000000\n  b     chr2    92-101      + |         2  0.888889\n  c     chr2    93-102      + |         3  0.777778\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n\n\nTo include the downstream bases:\n\nflank(g, 10, start=FALSE)\n\nGRanges object with 3 ranges and 2 metadata columns:\n    seqnames    ranges strand |     score        GC\n       &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt;\n  a     chr1    91-100      - |         1  1.000000\n  b     chr2   113-122      + |         2  0.888889\n  c     chr2   114-123      + |         3  0.777778\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n\n\nWe can shift the ranges by a specific number of bases with shift. This is performed is a strand independent manner.\n\n# Shift (same direction) both start and end by N bp \nshift(g, -5)\n\nGRanges object with 3 ranges and 2 metadata columns:\n    seqnames    ranges strand |     score        GC\n       &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt;\n  a     chr1    96-106      - |         1  1.000000\n  b     chr2    97-107      + |         2  0.888889\n  c     chr2    98-108      + |         3  0.777778\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n\n\nThe resize method will extend the ranges by a specified width from the start in a strand dependent manner.\n\n# Rize width to N bp (from start)\nresize(g, 5)\n\nGRanges object with 3 ranges and 2 metadata columns:\n    seqnames    ranges strand |     score        GC\n       &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt;\n  a     chr1   107-111      - |         1  1.000000\n  b     chr2   102-106      + |         2  0.888889\n  c     chr2   103-107      + |         3  0.777778\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n\n\n\n\nInter-range functions\nTransform all the ranges together as a set to produce a new set of ranges.\n\ngr\n\nGRanges object with 10 ranges and 2 metadata columns:\n    seqnames    ranges strand |     score        GC\n       &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt;\n  a     chr1   101-111      - |         1  1.000000\n  b     chr2   102-112      + |         2  0.888889\n  c     chr2   103-113      + |         3  0.777778\n  d     chr2   104-114      * |         4  0.666667\n  e     chr1   105-115      * |         5  0.555556\n  f     chr1   106-116      + |         6  0.444444\n  g     chr3   107-117      + |         7  0.333333\n  h     chr3   108-118      + |         8  0.222222\n  i     chr3   109-119      - |         9  0.111111\n  j     chr3   110-120      - |        10  0.000000\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n\n\n\nAlign the ranges and merge overlapping ranges to produce a simplified set. It maintains information related to the strand.\n\n\n#Merge overlapping intervals\nreduce(gr) %&gt;% arrange(start)\n\nGRanges object with 7 ranges and 0 metadata columns:\n      seqnames    ranges strand\n         &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt;\n  [1]     chr1   101-111      -\n  [2]     chr2   102-113      +\n  [3]     chr2   104-114      *\n  [4]     chr1   105-115      *\n  [5]     chr1   106-116      +\n  [6]     chr3   107-118      +\n  [7]     chr3   109-120      -\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n\n\n\nRetrieve the gaps between the ranges\n\nFor example, it might be useful to retrieve all regions not bound by a transcription factor to interrogate further.\n\n# Retrieve the gaps between the intervals\ngaps(gr)\n\nGRanges object with 7 ranges and 0 metadata columns:\n      seqnames    ranges strand\n         &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt;\n  [1]     chr1     1-105      +\n  [2]     chr1     1-100      -\n  [3]     chr1     1-104      *\n  [4]     chr2     1-101      +\n  [5]     chr2     1-103      *\n  [6]     chr3     1-106      +\n  [7]     chr3     1-108      -\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n\n\n\nA collection of non-overlapping ranges\n\nRather than merging intervals that overlap by 1 bp, it retrieves the complete overlapping plus non-overlapping regions.\n\n# Returns the non-overlapping regions\ndisjoin(gr)\n\nGRanges object with 13 ranges and 0 metadata columns:\n       seqnames    ranges strand\n          &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt;\n   [1]     chr1   106-116      +\n   [2]     chr1   101-111      -\n   [3]     chr1   105-115      *\n   [4]     chr2       102      +\n   [5]     chr2   103-112      +\n   ...      ...       ...    ...\n   [9]     chr3   108-117      +\n  [10]     chr3       118      +\n  [11]     chr3       109      -\n  [12]     chr3   110-119      -\n  [13]     chr3       120      -\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n\n\n\nQuantify the degree of overlap for all the ranges in a GRanges object.\n\n\n# Example GRanges object\ng &lt;- GRanges(seqnames = c(\"chr1\", \"chr1\", \"chr2\"),\n             ranges = IRanges(start = c(1, 3, 4), end = c(4, 6, 7)),\n             strand = rep('+',3)\n             #strand = Rle(strand('+'),3)\n             #strand = Rle(rep('+',3))\n             )\n\n# = Rle(strand(c(\"-\", \"+\", \"*\", \"+\", \"-\")), c(1, 2, 2, 3, 2))\ng\n\nGRanges object with 3 ranges and 0 metadata columns:\n      seqnames    ranges strand\n         &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt;\n  [1]     chr1       1-4      +\n  [2]     chr1       3-6      +\n  [3]     chr2       4-7      +\n  -------\n  seqinfo: 2 sequences from an unspecified genome; no seqlengths\n\n\n\ncoverage(g)\n\nRleList of length 2\n$chr1\ninteger-Rle of length 6 with 3 runs\n  Lengths: 2 2 2\n  Values : 1 2 1\n\n$chr2\ninteger-Rle of length 7 with 2 runs\n  Lengths: 3 4\n  Values : 0 1\n\n\n\n# Convert to dataframe\n# Compute coverage (returns an RleList)\ncovg &lt;- coverage(g)\n\n# Convert coverage to a data frame\ndf_list &lt;- lapply(names(covg), function(chr) {\n  data.frame(\n    seqnames = chr,\n    position = seq_along(covg[[chr]]),  # Positions along the chromosome\n    coverage = as.vector(covg[[chr]])   # Convert Rle to numeric vector\n  )\n})\n\n# Combine into a single data frame\ndf &lt;- do.call(rbind, df_list)\ndf\n\n   seqnames position coverage\n1      chr1        1        1\n2      chr1        2        1\n3      chr1        3        2\n4      chr1        4        2\n5      chr1        5        1\n6      chr1        6        1\n7      chr2        1        0\n8      chr2        2        0\n9      chr2        3        0\n10     chr2        4        1\n11     chr2        5        1\n12     chr2        6        1\n13     chr2        7        1"
  },
  {
    "objectID": "IntroGR/pages/GRanges_gtf.html#interval-set-operations-for-granges-objects",
    "href": "IntroGR/pages/GRanges_gtf.html#interval-set-operations-for-granges-objects",
    "title": "GRanges",
    "section": "Interval set operations for GRanges objects",
    "text": "Interval set operations for GRanges objects\nPerform operations between two GRanges objects.\n\ng &lt;- gr[1:3]\ng2 &lt;- head(gr, n=2)\n\ng\n\nGRanges object with 3 ranges and 2 metadata columns:\n    seqnames    ranges strand |     score        GC\n       &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt;\n  a     chr1   101-111      - |         1  1.000000\n  b     chr2   102-112      + |         2  0.888889\n  c     chr2   103-113      + |         3  0.777778\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n\ng2\n\nGRanges object with 2 ranges and 2 metadata columns:\n    seqnames    ranges strand |     score        GC\n       &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt;\n  a     chr1   101-111      - |         1  1.000000\n  b     chr2   102-112      + |         2  0.888889\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n\n\nRetrieve the union of regions.\n\n# Combined ranges\nGenomicRanges::union(g, g2)\n\nGRanges object with 2 ranges and 0 metadata columns:\n      seqnames    ranges strand\n         &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt;\n  [1]     chr1   101-111      -\n  [2]     chr2   102-113      +\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n\n\nRetrieve overlapping regions.\n\n# Overlapping regions\nGenomicRanges::intersect(g, g2)\n\nGRanges object with 2 ranges and 0 metadata columns:\n      seqnames    ranges strand\n         &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt;\n  [1]     chr1   101-111      -\n  [2]     chr2   102-112      +\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n\n\nRetrieve the non-overlapping regions.\n\n# Non overlapping regions\nGenomicRanges::setdiff(g, g2)\n\nGRanges object with 1 range and 0 metadata columns:\n      seqnames    ranges strand\n         &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt;\n  [1]     chr2       113      +\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths"
  },
  {
    "objectID": "IntroGR/pages/GRanges_gtf.html#splitting-and-combining-granges-objects",
    "href": "IntroGR/pages/GRanges_gtf.html#splitting-and-combining-granges-objects",
    "title": "GRanges",
    "section": "Splitting and combining GRanges objects",
    "text": "Splitting and combining GRanges objects\nGRanges objects can be divided into groups using the split function. This produces a GRangesList object.\n\n# Split using a factor that defines the grouping `rep(1:2, each=5)`. Use `time` instead of `each`.\nsp &lt;- split(gr, rep(1:2, each=5))\nsp\n\nGRangesList object of length 2:\n$`1`\nGRanges object with 5 ranges and 2 metadata columns:\n    seqnames    ranges strand |     score        GC\n       &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt;\n  a     chr1   101-111      - |         1  1.000000\n  b     chr2   102-112      + |         2  0.888889\n  c     chr2   103-113      + |         3  0.777778\n  d     chr2   104-114      * |         4  0.666667\n  e     chr1   105-115      * |         5  0.555556\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n\n$`2`\nGRanges object with 5 ranges and 2 metadata columns:\n    seqnames    ranges strand |     score        GC\n       &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt;\n  f     chr1   106-116      + |         6  0.444444\n  g     chr3   107-117      + |         7  0.333333\n  h     chr3   108-118      + |         8  0.222222\n  i     chr3   109-119      - |         9  0.111111\n  j     chr3   110-120      - |        10  0.000000\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n\n\nSet the names of the two items in the list\n\n# Name the two elements of the lists\nnames(sp) &lt;- c('A','B')\n\nCheck the length of each item\n\nlengths(sp)\n\nA B \n5 5 \n\n\n\n# Retrieve the first item in the list\n#sp[[1]]\nsp$A\n\nGRanges object with 5 ranges and 2 metadata columns:\n    seqnames    ranges strand |     score        GC\n       &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt;\n  a     chr1   101-111      - |         1  1.000000\n  b     chr2   102-112      + |         2  0.888889\n  c     chr2   103-113      + |         3  0.777778\n  d     chr2   104-114      * |         4  0.666667\n  e     chr1   105-115      * |         5  0.555556\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n\n\nConcatenate the two lists\n\n# Concatenate \nc(sp[[1]], sp[[2]])\n\nGRanges object with 10 ranges and 2 metadata columns:\n    seqnames    ranges strand |     score        GC\n       &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt;\n  a     chr1   101-111      - |         1  1.000000\n  b     chr2   102-112      + |         2  0.888889\n  c     chr2   103-113      + |         3  0.777778\n  d     chr2   104-114      * |         4  0.666667\n  e     chr1   105-115      * |         5  0.555556\n  f     chr1   106-116      + |         6  0.444444\n  g     chr3   107-117      + |         7  0.333333\n  h     chr3   108-118      + |         8  0.222222\n  i     chr3   109-119      - |         9  0.111111\n  j     chr3   110-120      - |        10  0.000000\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n\n\nA useful and fast strategy is to unlist the GRangesList to a GRanges object, operate on the GRanges object, then relist the result.\n\n# Unlist into a GRanges object\nunlist(sp)\n\nGRanges object with 10 ranges and 2 metadata columns:\n      seqnames    ranges strand |     score        GC\n         &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt;\n  A.a     chr1   101-111      - |         1  1.000000\n  A.b     chr2   102-112      + |         2  0.888889\n  A.c     chr2   103-113      + |         3  0.777778\n  A.d     chr2   104-114      * |         4  0.666667\n  A.e     chr1   105-115      * |         5  0.555556\n  B.f     chr1   106-116      + |         6  0.444444\n  B.g     chr3   107-117      + |         7  0.333333\n  B.h     chr3   108-118      + |         8  0.222222\n  B.i     chr3   109-119      - |         9  0.111111\n  B.j     chr3   110-120      - |        10  0.000000\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n\n\nSplitting can be performed based on genomic coordinate information or metadata.\n\n# Split by chromosome\nsingles &lt;- split(gr, seqnames(gr))\nnames(singles)\n\n[1] \"chr1\" \"chr2\" \"chr3\"\n\nsingles\n\nGRangesList object of length 3:\n$chr1\nGRanges object with 3 ranges and 2 metadata columns:\n    seqnames    ranges strand |     score        GC\n       &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt;\n  a     chr1   101-111      - |         1  1.000000\n  e     chr1   105-115      * |         5  0.555556\n  f     chr1   106-116      + |         6  0.444444\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n\n$chr2\nGRanges object with 3 ranges and 2 metadata columns:\n    seqnames    ranges strand |     score        GC\n       &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt;\n  b     chr2   102-112      + |         2  0.888889\n  c     chr2   103-113      + |         3  0.777778\n  d     chr2   104-114      * |         4  0.666667\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n\n$chr3\nGRanges object with 4 ranges and 2 metadata columns:\n    seqnames    ranges strand |     score        GC\n       &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt;\n  g     chr3   107-117      + |         7  0.333333\n  h     chr3   108-118      + |         8  0.222222\n  i     chr3   109-119      - |         9  0.111111\n  j     chr3   110-120      - |        10  0.000000\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n\n\n\n# Split based on metadata information\nsingles &lt;- split(gr, mcols(gr)$score&lt;4)\nsingles\n\nGRangesList object of length 2:\n$`FALSE`\nGRanges object with 7 ranges and 2 metadata columns:\n    seqnames    ranges strand |     score        GC\n       &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt;\n  d     chr2   104-114      * |         4  0.666667\n  e     chr1   105-115      * |         5  0.555556\n  f     chr1   106-116      + |         6  0.444444\n  g     chr3   107-117      + |         7  0.333333\n  h     chr3   108-118      + |         8  0.222222\n  i     chr3   109-119      - |         9  0.111111\n  j     chr3   110-120      - |        10  0.000000\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n\n$`TRUE`\nGRanges object with 3 ranges and 2 metadata columns:\n    seqnames    ranges strand |     score        GC\n       &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt;\n  a     chr1   101-111      - |         1  1.000000\n  b     chr2   102-112      + |         2  0.888889\n  c     chr2   103-113      + |         3  0.777778\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n\n\nHow would you split for start position less than 106 and GC more than 0.7\nIt is also possible to append an interval to the GRanges object\n\n# Append to the ranges\ng &lt;- gr[1:3]\ng &lt;- append(g, singles[[1]][1])\ng\n\nGRanges object with 4 ranges and 2 metadata columns:\n    seqnames    ranges strand |     score        GC\n       &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt;\n  a     chr1   101-111      - |         1  1.000000\n  b     chr2   102-112      + |         2  0.888889\n  c     chr2   103-113      + |         3  0.777778\n  d     chr2   104-114      * |         4  0.666667\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n\nsingles[[1]][1]\n\nGRanges object with 1 range and 2 metadata columns:\n    seqnames    ranges strand |     score        GC\n       &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt;\n  d     chr2   104-114      * |         4  0.666667\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n\n\nOr replace a genomic interval\n\n# Replace a genomic interval\ng[2] &lt;- singles[[1]][2]\ng\n\nGRanges object with 4 ranges and 2 metadata columns:\n    seqnames    ranges strand |     score        GC\n       &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt;\n  a     chr1   101-111      - |         1  1.000000\n  b     chr1   105-115      * |         5  0.555556\n  c     chr2   103-113      + |         3  0.777778\n  d     chr2   104-114      * |         4  0.666667\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n\nsingles[[1]][2]\n\nGRanges object with 1 range and 2 metadata columns:\n    seqnames    ranges strand |     score        GC\n       &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt; | &lt;integer&gt; &lt;numeric&gt;\n  e     chr1   105-115      * |         5  0.555556\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n\n\nReplace a value of a genomic interval\n\n# Replace the strand in the second interval\nmcols(g)$score[3] &lt;- 10\nstrand(g[2]) &lt;- '+'\ng\n\nGRanges object with 4 ranges and 2 metadata columns:\n    seqnames    ranges strand |     score        GC\n       &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt; | &lt;numeric&gt; &lt;numeric&gt;\n  a     chr1   101-111      - |         1  1.000000\n  b     chr1   105-115      + |         5  0.555556\n  c     chr2   103-113      + |        10  0.777778\n  d     chr2   104-114      * |         4  0.666667\n  -------\n  seqinfo: 3 sequences from an unspecified genome; no seqlengths\n\n\n\n# gr[IRanges(start=c(2,7), end=c(3,8))] # genomic intervals [2:3] and [7:8]: from 2nd to 3rd row and from 7th to 8th row\n# gr %&gt;% filter(start&lt;107, start&gt;102)\n\n\n#help(\"inter-range-methods\", package = \"GenomicRanges\")\n#?`inter-range-methods`\n\n\nGRanges offers parallel methods when two objects have matching structures, e.g. element 1 of one object corresponds to element 1 of the other. These methods, which start with “p” (for parallel), perform element-wise operations like unions. Both objects must have the same number of elements, with matching seqnames and strand throughout."
  },
  {
    "objectID": "IntroGR/pages/GRanges_gtf.html#online-resources-and-databases-for-omics-data",
    "href": "IntroGR/pages/GRanges_gtf.html#online-resources-and-databases-for-omics-data",
    "title": "GRanges",
    "section": "Online Resources and Databases for omics data",
    "text": "Online Resources and Databases for omics data\nThe section below briefly introduce you to the description and usage of some very useful online resources for ChIP-seq public data and also other omics data. Take a closer look to explore them, you might need them in the future in order to complement your future experiments!\n\nPoor man’s guide to omics\nWhen approaching a new problem, you might conceive multiple hypotheses that could instruct a wide variety of experimental approaches. However, you have neither the time, nor the money or the inclination to perform all of these experiments. Chances are, though, that somewhere in a server there is a dataset that can help you, be it a ChIP-seq dataset or any other omic. They may not give you an answer outright, but they’ll help you prune your hypotheses and only keep the ones that have some foundation. After all, while big data analysis often results in false positives, or at least positives that are contingent to a specific model, it is very useful to avoid pursuing roads for which no evidence is found in datasets.\nThis section aims to give you resources that you can employ to perform simple analyses that prevent you from wasting your time and allow you to focus on the experiments that matter.\nOver the years, multiple consortia have assembled these datasets into curated collections, and new datasets are published with almost every new paper, neatly stored into various sites.\nHere we provide a handful of key databases and characteristics of the main ones, as well as a list of other databases that may be useful for more specific questions.\n\nENCODE: the encyclopedia of DNA elements\nThe closest to the object of the workshop, over more than 20 years of activity the ENCODE consortium is the biggest effort in functional genomics in the world, assembling thousands of datasets. You can easily browse their portal by theme and find ready-made datasets that pertain to your field. Once you have your dataset (or datasets) of choice, you only have to browse it with the help of this workshop’s scripts or visualize it, for example with IGV.\nEncode project\n\n\nGEO: The Gene Expression Omnibus\nThis portal is almost ubiquitous in publications - in fact, nearly all gene expression datasets used in publications, both bulk and single cell, are published on the GEO, a service handled by the NCBI. The GEO datasets can be accessed from papers, but also directly from the portal, and the neat thing is that they are generally well annotated so that you can understand how specific experiments were performed. They have specific files that tell you how the data was generated. This kind of information can be complementary to epigenome data, or can inform derivative work giving you invaluable insight into a model you want to adopt.\nGene Expression Omnibus\n\n\nTCGA: The Cancer Genome Atlas\nAmong the biggest efforts in contemporary medical research, spearheaded by the NIH. The Cancer Genome Atlas has gathered transcriptomics, methylation, and chromatin accessibility data for an incredibly wide array of malignancies, and it keeps expanding with new cohorts of patients, curated by individual contributors. While it is a specific resource pertaining to oncology, its wealth of controls and diversity of malignancies makes it invaluable for anybody working on human biology - after all, most fundamental biology experiments are performed on cancer cell lines.\nThe Cancer Genome Atlas\n\n\nThe Human Cell Atlas\nArguably the biggest ongoing sequencing project in the world, the Human Cell Atlas aims to fully leverage single cell transcriptomes to define every cell type in the human body. Currently hosting data for close to 60 million sequenced cells and still counting, this is the largest single-cell resolved gene expression resource currently available for non-diseased tissue. Allows downloads in formats that are ‘easily’ browsed - meaning you don’t have to do core processing yourself.\nThe Human Cell Atlas - HCA\n\n\nAdditional links:\nRoadmap consortium Generated tracks for multiple modifications, and produced ChromHMM to sort them out\nEBI Bioimage Archive European resource for bioimages. Pretty unique and specific, rare type of datasets.\nGTEX Tissue-specific genotype regulation - a complex database that can tell you whether your gene of interest works in the context you study.\nBrown university collection Collection of resources, including some of those we showed above. Take a look when you need to find some new source of data!\nNIH’s collection - even better than Brown’s! Includes even more well-categorized resources."
  },
  {
    "objectID": "Gviz/pages/Genomic_overviews_with_Gviz.html",
    "href": "Gviz/pages/Genomic_overviews_with_Gviz.html",
    "title": "Gviz",
    "section": "",
    "text": "PLotting data and annotation information along genomic coordinates"
  },
  {
    "objectID": "Gviz/pages/Genomic_overviews_with_Gviz.html#introduction",
    "href": "Gviz/pages/Genomic_overviews_with_Gviz.html#introduction",
    "title": "Gviz",
    "section": "Introduction",
    "text": "Introduction\nThe Gviz package (Hahne and Ivanek 2016) aims to close this gap by providing a structured visualization framework to plot any type of data along genomic coordinates. It is loosely based on the GenomeGraphs package by Steffen Durinck and James Bullard, however the complete class hierarchy as well as all the plotting methods have been restructured in order to increase performance and flexibility. All plotting is done using the grid graphics system, and several specialized annotation classes allow to integrate publicly available genomic annotation data from sources like UCSC or ENSEMBL."
  },
  {
    "objectID": "Gviz/pages/Genomic_overviews_with_Gviz.html#concepts",
    "href": "Gviz/pages/Genomic_overviews_with_Gviz.html#concepts",
    "title": "Gviz",
    "section": "Concepts",
    "text": "Concepts\n\nIndividual types of genomic features or data are represented by separate tracks.\n\n\nAnnotationTrack\nGenomeAxisTrack\nIdeogramTrack\nGeneRegionTrack\nSequenceTrack\nDataTrack\n\n\nWhen combining multiple objects, the individual tracks will always share the same genomic coordinate system.\nTracks may contain information for multiple chromosomes, however most of this is hidden except for the currently active chromosome during a given plotting operation.\nIn Bioconductor, genomic features consisting of start and stop coordinates are most often represented as run-length encoded vectors, e.g. IRanges and GRanges classes.\n\n\nBioconductor: open source software for Bioinformatics"
  },
  {
    "objectID": "Gviz/pages/Genomic_overviews_with_Gviz.html#load-libraries",
    "href": "Gviz/pages/Genomic_overviews_with_Gviz.html#load-libraries",
    "title": "Gviz",
    "section": "Load libraries",
    "text": "Load libraries\n\n# suppressWarnings({\n#   if (!require(\"BiocManager\"))\n#     install.packages(\"BiocManager\", \"Gviz\")\n# })\n\nif (!require(\"BiocManager\"))\n    install.packages(\"BiocManager\", \"Gviz\")\n\n#BiocManager::install(\"dplyr\")\n#BiocManager::install(\"Gviz\")\n\n\nsuppressWarnings({\n  library(BiocManager)\n  library(GenomicRanges)\n  library(Gviz)\n  library(biomaRt)\n  library(rtracklayer)\n})"
  },
  {
    "objectID": "Gviz/pages/Genomic_overviews_with_Gviz.html#annotation-track-annotationtrack",
    "href": "Gviz/pages/Genomic_overviews_with_Gviz.html#annotation-track-annotationtrack",
    "title": "Gviz",
    "section": "Annotation Track: AnnotationTrack()",
    "text": "Annotation Track: AnnotationTrack()\nGenerate Track for CpG Islands and plot\n\nImport data on CpG islands\n\ndata(cpgIslands)\nclass(cpgIslands)\n\n[1] \"GRanges\"\nattr(,\"package\")\n[1] \"GenomicRanges\"\n\n\n\n\nInspect GRanges object\n\ncpgIslands\n\nGRanges object with 10 ranges and 0 metadata columns:\n       seqnames            ranges strand\n          &lt;Rle&gt;         &lt;IRanges&gt;  &lt;Rle&gt;\n   [1]     chr7 26549019-26550183      *\n   [2]     chr7 26564119-26564500      *\n   [3]     chr7 26585667-26586158      *\n   [4]     chr7 26591772-26593309      *\n   [5]     chr7 26594192-26594570      *\n   [6]     chr7 26623835-26624150      *\n   [7]     chr7 26659284-26660352      *\n   [8]     chr7 26721294-26721717      *\n   [9]     chr7 26821518-26823297      *\n  [10]     chr7 26991322-26991841      *\n  -------\n  seqinfo: 1 sequence from hg19 genome; no seqlengths\n\n\n\n\nRetrieve information of genome and sequence\n\nchr &lt;- as.character(unique(seqnames(cpgIslands)))\ngen &lt;- \"hg19\"\nchr\n\n[1] \"chr7\"\n\ngen\n\n[1] \"hg19\"\n\n\n\n\nGenerate Annotation Track\n\natrack &lt;- AnnotationTrack(cpgIslands, name = \"CpG\")\n\n\n\nPlot\n\nplotTracks(atrack)"
  },
  {
    "objectID": "Gviz/pages/Genomic_overviews_with_Gviz.html#genome-axis-track-genomeaxistrack",
    "href": "Gviz/pages/Genomic_overviews_with_Gviz.html#genome-axis-track-genomeaxistrack",
    "title": "Gviz",
    "section": "Genome Axis Track: GenomeAxisTrack()",
    "text": "Genome Axis Track: GenomeAxisTrack()\n\nDisplay the genomic coordinates to provide reference.\nA GenomeAxisTrack object is always relative to the other tracks that are plotted.\nNo need to know in advance about a particular genomic location when constructing the object. The displayed coordinates will be determined from the context, e.g., from the from and to arguments of the plotTracks function, or, when plotted together with other track objects, from their genomic locations.\n\n\nGenerate GenomeAxisTrack()\n\ngtrack &lt;- GenomeAxisTrack()\n\n\n\nPlot\n\nplotTracks(list(gtrack, atrack))"
  },
  {
    "objectID": "Gviz/pages/Genomic_overviews_with_Gviz.html#chromosome-ideogram-track-ideogramtrack",
    "href": "Gviz/pages/Genomic_overviews_with_Gviz.html#chromosome-ideogram-track-ideogramtrack",
    "title": "Gviz",
    "section": "Chromosome Ideogram Track: IdeogramTrack()",
    "text": "Chromosome Ideogram Track: IdeogramTrack()\n\nAn ideogram is a simplified visual representation of a chromosome, with the different chromosomal staining bands indicated by color, and the centromere (if present) indicated by the shape.\nWe can fetch the chromosome ideogram information directly from UCSC (need an established internet connection for this to work)\nNeed to provide the information about a valid UCSC genome and chromosome.\nA plotted track is always defined for exactly one chromosome on a particular genome.\nThe chromosomal data necessary to draw the ideogram is not part of the Gviz package itself, instead it is downloaded from an online source (UCSC).\n\n\n#options(Gviz.ucscUrl=\"http://genome-euro.ucsc.edu/cgi-bin/\")\n\nCheck if you are able to generate the ideogram track. If yes, you can add this track every time you call the function plotTracks().\n\n#itrack &lt;- IdeogramTrack(genome = gen, chromosome = chr)\n\n\nplotTracks(list(gtrack, atrack))\n\n\n\n\n\n\n\n#plotTracks(list(itrack, gtrack, atrack))"
  },
  {
    "objectID": "Gviz/pages/Genomic_overviews_with_Gviz.html#lets-explore-the-environment-and-objects-so-far",
    "href": "Gviz/pages/Genomic_overviews_with_Gviz.html#lets-explore-the-environment-and-objects-so-far",
    "title": "Gviz",
    "section": "Let’s explore the environment and objects so far!",
    "text": "Let’s explore the environment and objects so far!\n\nCheck the environment\n\n\nls()\n\n[1] \"atrack\"     \"chr\"        \"cpgIslands\" \"gen\"        \"gtrack\"    \n\n\n\nCheck the objects\n\n\natrack\n\nAnnotationTrack 'CpG'\n| genome: hg19\n| active chromosome: chr7\n| annotation features: 10\n\n\n\natrack@range\n\nGRanges object with 10 ranges and 4 metadata columns:\n       seqnames            ranges strand |     feature       group          id\n          &lt;Rle&gt;         &lt;IRanges&gt;  &lt;Rle&gt; | &lt;character&gt; &lt;character&gt; &lt;character&gt;\n   [1]     chr7 26549019-26550183      * |     unknown           1     unknown\n   [2]     chr7 26564119-26564500      * |     unknown           2   unknown.1\n   [3]     chr7 26585667-26586158      * |     unknown           3   unknown.2\n   [4]     chr7 26591772-26593309      * |     unknown           4   unknown.3\n   [5]     chr7 26594192-26594570      * |     unknown           5   unknown.4\n   [6]     chr7 26623835-26624150      * |     unknown           6   unknown.5\n   [7]     chr7 26659284-26660352      * |     unknown           7   unknown.6\n   [8]     chr7 26721294-26721717      * |     unknown           8   unknown.7\n   [9]     chr7 26821518-26823297      * |     unknown           9   unknown.8\n  [10]     chr7 26991322-26991841      * |     unknown          10   unknown.9\n         density\n       &lt;numeric&gt;\n   [1]         1\n   [2]         1\n   [3]         1\n   [4]         1\n   [5]         1\n   [6]         1\n   [7]         1\n   [8]         1\n   [9]         1\n  [10]         1\n  -------\n  seqinfo: 1 sequence from hg19 genome; no seqlengths\n\n\n\n#itrack@bandTable\n\n\n#itrack@range\n\n\nExercise 1\nChange the order of the objects plotted"
  },
  {
    "objectID": "Gviz/pages/Genomic_overviews_with_Gviz.html#gene-model-information-generegiontrack",
    "href": "Gviz/pages/Genomic_overviews_with_Gviz.html#gene-model-information-generegiontrack",
    "title": "Gviz",
    "section": "Gene Model information: GeneRegionTrack()",
    "text": "Gene Model information: GeneRegionTrack()\n\nDisplay information on gene structure from local source or online resources like UCSC and Ensembl\n\n\nLoad gene model data from a stored data.frame\n\ndata(geneModels)\nhead(geneModels,2)\n\n  chromosome    start      end width strand feature            gene\n1       chr7 26591441 26591829   389      + lincRNA ENSG00000233760\n2       chr7 26591458 26591829   372      + lincRNA ENSG00000233760\n             exon      transcript     symbol\n1 ENSE00001693369 ENST00000420912 AC004947.2\n2 ENSE00001596777 ENST00000457000 AC004947.2\n\n\n\n\nGenerate Track and plot\n\ngrtrack &lt;- GeneRegionTrack(geneModels, genome = gen,\n                           chromosome = chr, name = \"Gene Model\")\n#plotTracks(list(itrack, gtrack, atrack, grtrack))\nplotTracks(list( gtrack, atrack, grtrack))\n\n\n\n\n\n\n\n\n\nhead(geneModels,2)\n\n  chromosome    start      end width strand feature            gene\n1       chr7 26591441 26591829   389      + lincRNA ENSG00000233760\n2       chr7 26591458 26591829   372      + lincRNA ENSG00000233760\n             exon      transcript     symbol\n1 ENSE00001693369 ENST00000420912 AC004947.2\n2 ENSE00001596777 ENST00000457000 AC004947.2\n\n\n\n\nZoom in to the region\n\nplotTracks(list(gtrack, atrack, grtrack),\n           from = 26700000, to = 26750000)\n\n\n\n\n\n\n\n\n\nThe layout of the gene model track has changed depending on the zoom level. This is a feature of the Gviz package, which automatically tries to find the optimal visualization settings to make best use of the available space."
  },
  {
    "objectID": "Gviz/pages/Genomic_overviews_with_Gviz.html#display-the-genomic-sequence-at-a-given-position-sequencetrack",
    "href": "Gviz/pages/Genomic_overviews_with_Gviz.html#display-the-genomic-sequence-at-a-given-position-sequencetrack",
    "title": "Gviz",
    "section": "Display the Genomic Sequence at a given position: SequenceTrack()",
    "text": "Display the Genomic Sequence at a given position: SequenceTrack()\n\nThe track class SequenceTrack can draw the necessary sequence information from one of the BSgenome packages.\nCreate track for a specific chromosome\n\n\nlibrary(BSgenome.Hsapiens.UCSC.hg19)\nstrack &lt;- SequenceTrack(Hsapiens, chromosome = chr)\nplotTracks(list(gtrack, atrack, grtrack, strack), \n           from = 26591822, to = 26591852, cex = 0.8)"
  },
  {
    "objectID": "Gviz/pages/Genomic_overviews_with_Gviz.html#incoorporate-data-datatrack",
    "href": "Gviz/pages/Genomic_overviews_with_Gviz.html#incoorporate-data-datatrack",
    "title": "Gviz",
    "section": "Incoorporate Data: DataTrack()",
    "text": "Incoorporate Data: DataTrack()\n\nAnnotate genomic coordinate plots with real numeric data\nDifferent visualization options for these tracks, from dot plots to histograms to box-and-whisker plots.\nThe individual rows in a numeric matrix are considered to be different data groups or samples, and the columns are the intervals in the genomic coordinates.\n\n\nset.seed(255)\nlim &lt;- c(26700000, 26750000)\ncoords &lt;- sort(c(lim[1], \n                 sample(seq(from = lim[1], to = lim[2]), 99), \n                 lim[2]))\ndat &lt;- runif(100, min = -10, max = 10)\ndtrack &lt;- DataTrack(data = dat, start = coords[-length(coords)],\n                    end = coords[-1], chromosome = chr, genome = gen, \n                    name = \"Uniform\")\nplotTracks(list(gtrack, atrack, grtrack, dtrack), \n           from = lim[1], to = lim[2])\n\n\n\n\n\n\n\n\nChange plot type to histogram\n\nplotTracks(list(gtrack, atrack, grtrack, dtrack), \n           from = lim[1], to = lim[2], type = \"histogram\")\n\n\n\n\n\n\n\n\n\nCase Use of the DataTracks + Display the coverage of NGS reads along a chromosome + Show the measurement values of mapped probes from a microarray experiment"
  },
  {
    "objectID": "Gviz/pages/Genomic_overviews_with_Gviz.html#global-control-parameters",
    "href": "Gviz/pages/Genomic_overviews_with_Gviz.html#global-control-parameters",
    "title": "Gviz",
    "section": "Global Control Parameters",
    "text": "Global Control Parameters\n\n1. Specify parameters during Track generation\n\ngrtrack &lt;- GeneRegionTrack(geneModels, genome = gen, chromosome = chr, \n                           name = \"Gene Model\",\n                           transcriptAnnotation = \"symbol\",\n                           background.title = \"brown\")\n\nplotTracks(list(gtrack, atrack, grtrack))\n\n\n\n\n\n\n\n\n\n\n2. Modify parameters with displayPars()\nDisplay track parameters\n\nhead(displayPars(grtrack))\n\nModify parameters for background colors in the GeneRegion track\n\ndisplayPars(grtrack) &lt;- list(background.panel = \"#FFFEDB\", background.title = \"darkorange\")\n\n\nplotTracks(list(gtrack, atrack, grtrack))\n\n\n\n\n\n\n\n\n\n\n3. Set display parameters for a single plotting operation\n\nBy passing in additional arguments to the plotTracks function, instead of the permanent setting in the track object\n\n\nplotTracks(list(gtrack, atrack, grtrack), \n           background.panel = \"#FFFEDB\", background.title = \"darkblue\", fontcolor.title='white')\n\n\n\n\n\n\n\n\n\nTip!\nThe availableDisplayPars function prints out the available parameters for a class as well as their default values in a list-like structure.\n\n\n\nExercise 2\nChange the color of the font title: - 1. In the GeneRegion track - 2. In all tracks"
  },
  {
    "objectID": "Gviz/pages/Genomic_overviews_with_Gviz.html#parameters-for-data-track",
    "href": "Gviz/pages/Genomic_overviews_with_Gviz.html#parameters-for-data-track",
    "title": "Gviz",
    "section": "Parameters for Data Track",
    "text": "Parameters for Data Track\n\nTo display one or several numeric values that are associated to a particular genomic coordinate range\nWhen we need to incorporate sample group information\n\n\nInput\n\na set of ranges, either in the form of an IRanges or GRanges object\na numeric vector (or matrix) of the same length as the number of ranges\n\n\n\nImport data on multiple replicates for control and treated samples\n\ndata(twoGroups)\ntwoGroups\n\nGRanges object with 25 ranges and 6 metadata columns:\n       seqnames    ranges strand |   control control.1 control.2   treated\n          &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt; | &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt;\n   [1]     chrX      1-30      * | -8.961260  -7.65790  9.879565  -5.84376\n   [2]     chrX     42-71      * | -4.211471   4.68826 -1.053306   1.03084\n   [3]     chrX    84-113      * |  2.287112   8.01327 -7.121998  -4.46718\n   [4]     chrX   125-154      * |  9.209838  -6.23243  8.596822  -6.32041\n   [5]     chrX   167-196      * |  0.406842  -7.05442 -0.551974   9.36363\n   ...      ...       ...    ... .       ...       ...       ...       ...\n  [21]     chrX   833-862      * |  2.712424  7.538538   6.56281  -3.42396\n  [22]     chrX   875-904      * |  0.727043 -0.950022  -7.63786 -28.96335\n  [23]     chrX   916-945      * |  7.386881  4.817002   3.64004  -7.59088\n  [24]     chrX   958-987      * | -5.541625 -2.231180  -4.65625   7.04730\n  [25]     chrX 1000-1029      * | -1.139128  2.861125   8.17754  -5.34925\n        treated.1 treated.2\n        &lt;numeric&gt; &lt;numeric&gt;\n   [1]    9.71353  9.993286\n   [2]   -6.77430  0.593712\n   [3]   -4.05888  8.053195\n   [4]   -1.56806  3.511461\n   [5]   -4.88057  1.552880\n   ...        ...       ...\n  [21] -25.015912 -14.86389\n  [22] -15.066067 -26.36181\n  [23]   5.146919  -5.80432\n  [24]  -7.555974  -8.46894\n  [25]   0.874496  -6.32031\n  -------\n  seqinfo: 1 sequence from hg19 genome; no seqlengths\n\n\n\ndTrack &lt;- DataTrack(twoGroups, name = \"uniform\")\nplotTracks(dTrack)\n\n\n\n\n\n\n\n\n\nplotTracks(dTrack, type = c(\"boxplot\", \"a\", \"g\"))\n\n\n\n\n\n\n\n\n\ncolnames(mcols(twoGroups))\n\n[1] \"control\"   \"control.1\" \"control.2\" \"treated\"   \"treated.1\" \"treated.2\"\n\n\n\nplotTracks(dTrack, type = c(\"heatmap\"), showSampleNames = TRUE, \n           cex.sampleNames = 0.6)\n\n\n\n\n\n\n\n\n\n\nIntegrate information of data grouping\n\nSamples are grouped together based on a factor variable (e.g. control, treated).\nThe grouping is reflected in the layout of the respective track types.\nGrouping is not supported for all plotting types\n\n\nplotTracks( dTrack,  \n            groups = rep(c(\"control\", \"treated\"), each = 3), \n            type = c(\"a\", \"p\", \"confint\"), \n           from=1, to=1030, genome='hg19', chromosome='chrX'\n           )\n\n\n\n\n\n\n\n\n\n\n\nData Type Formats\n\n\n\n\nExercise 3\nDisplay tracks for chromosome ideogram and genome coordinates\n\nTip: Check the chromosome!"
  },
  {
    "objectID": "Gviz/pages/Genomic_overviews_with_Gviz.html#parameters-for-alignment-track",
    "href": "Gviz/pages/Genomic_overviews_with_Gviz.html#parameters-for-alignment-track",
    "title": "Gviz",
    "section": "Parameters for Alignment Track",
    "text": "Parameters for Alignment Track\n\nafrom &lt;- 44945200\nato &lt;- 44947200\nalTrack &lt;- AlignmentsTrack(\n  system.file(package = \"Gviz\", \"extdata\", \"snps.bam\"), isPaired = TRUE)\nplotTracks(alTrack, chromosome = \"chr21\", from = afrom, to = ato)\n\n\n\n\n\n\n\n\n\nplotTracks(alTrack, strack, chromosome = \"chr21\", from = afrom, to = ato)\n\n\n\n\n\n\n\n\n\nplotTracks(c(alTrack, strack), chromosome = \"chr21\",\n           from = 44946590, to = 44946660)\n\n\n\n\n\n\n\n\n\nplotTracks(c(alTrack, strack), chromosome = \"chr21\", from = 44946590, \n           to = 44946660, cex = 0.5, min.height = 8)"
  },
  {
    "objectID": "ChIP-seq_analysis/pages/ChIP-seq_analysis_part2.html",
    "href": "ChIP-seq_analysis/pages/ChIP-seq_analysis_part2.html",
    "title": "ChIP-seq_analysis_part2",
    "section": "",
    "text": "Downstream analysis of differential expression data\nPerform gene ontology analysis on interesting gene groups\nPerform gene set enrichment analysis\nInspecting data with Integrative Genome Viewer"
  },
  {
    "objectID": "ChIP-seq_analysis/pages/ChIP-seq_analysis_part2.html#objetives",
    "href": "ChIP-seq_analysis/pages/ChIP-seq_analysis_part2.html#objetives",
    "title": "ChIP-seq_analysis_part2",
    "section": "",
    "text": "Downstream analysis of differential expression data\nPerform gene ontology analysis on interesting gene groups\nPerform gene set enrichment analysis\nInspecting data with Integrative Genome Viewer"
  },
  {
    "objectID": "ChIP-seq_analysis/pages/ChIP-seq_analysis_part2.html#further-downstream-analyses",
    "href": "ChIP-seq_analysis/pages/ChIP-seq_analysis_part2.html#further-downstream-analyses",
    "title": "ChIP-seq_analysis_part2",
    "section": "Further downstream analyses",
    "text": "Further downstream analyses\nOnce we have our differentially enriched regions, we can perform various downstream analyses to check the functional aspects of the group of regions which are up- or down-regulated in our condition of interest.\n\nLoading tables\nFor these analyses, we will need to upload additional tables, that have been generated separately by us in order to speed up some computations and save memory. We introduced the content of these files on the first day, here we’ll do a brief recap.\n\nrecurrence_chr12.matrix: this is a table where you can find if any of the regions that constitute the consensus set of enhancer regions is identified as enhancers also in the individual samples.\nKorg_UP_regions_results.txt and Ncr_UP_regions_results.txt: these files store the differential analysis results for the entire set of enhancers across all the genome and not only chr12 and, importantly, the regions listed in these files are annotated to gene symbols (we will talk about genomic region annotation later).\n\nImport these files as R objects\n\nrecurrence_table &lt;- read.table(\"../MBMM25_uploadata//recurrence_chr12.matrix\", sep = \"\\t\")\n\n\ntumor_up_res &lt;- read.table(\"../MBMM25_uploadata/Korg_UP_regions_results.txt\", sep = \"\\t\", header = TRUE,\n    quote = \"\")\ntumor_down_res &lt;- read.table(\"../MBMM25_uploadata/Ncr_UP_regions_results.txt\", sep = \"\\t\", header = TRUE,\n    quote = \"\")"
  },
  {
    "objectID": "ChIP-seq_analysis/pages/ChIP-seq_analysis_part2.html#understanding-recurrence-of-enhancer-regions-across-patients",
    "href": "ChIP-seq_analysis/pages/ChIP-seq_analysis_part2.html#understanding-recurrence-of-enhancer-regions-across-patients",
    "title": "ChIP-seq_analysis_part2",
    "section": "Understanding recurrence of enhancer regions across patients",
    "text": "Understanding recurrence of enhancer regions across patients\nAs the paper presenting our studies reports:\n\n“To identify common epigenetic blueprints across the organoid library, we looked at the concordance of tumor-enriched enhancers in the PDOs (Patient-Derived Organoids).”\n\nOne of the downstream analyses that has been performed on the tumor-enriched enhancers (i.e. the enhancers with significantly higher H3K27ac signal compared to normal colon tissues) was aimed at understanding if there is a signature of genomic regions that are highly conserved and consistently active in the entire library of PDOs, which represent an especially interesting subset of regions being the most conserved enhancers.\nIn order to perform this analysis, we need to start from a binary table that indicates for each genomic region (i.e., the rows), if it was called as enhancer in each separate sample (i.e., the columns). This is our recurrence table:\n\ndim(recurrence_table)\nhead(recurrence_table, 5)\n\n\n\n\n\n\n\nSQ_2157\nSQ_1990\nSQ_2010\nSQ_2163\nSQ_2204\nSQ_2212\nSQ_2216\nSQ_2222\nSQ_2288\nSQ_2303\nSQ_2298\nSQ_2145\nGSM2058021\nGSM2058022\nGSM2058023\nCalled_Korg\nCalled_Ncr\n\n\n\n\nreg_6364\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n1\n1\n0\n0\n2\n\n\nreg_6365\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n0\n3\n\n\nreg_6366\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n0\n3\n\n\nreg_6367\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n0\n3\n\n\nreg_6368\n0\n0\n0\n0\n0\n0\n0\n0\n0\n1\n0\n0\n0\n0\n1\n1\n1\n\n\n\n\n\n\n\nIn order to get the number of PDO samples and normal samples that share each genomic region in the consensus, we need to calculate the row-wise sum of all the ‘1’s in the table. &gt; We have already performed this step for you: you can see the row-sums in the last two columns of the table, named ’Called_Korg’ and ‘Called_Ncr’ respectively for tumor and normal sample counts.\nWe will first extract the upregulated regions for chr12 using certain thresholds. Then we will retrieve information regarding the recurrence of these regions across all PDOs.\nAt this point we can use this code to generate a pie chart that illustrates the recurrence of the up-regulated regions across samples.\n\nres &lt;- read.table(\"../results/res_chr12.csv\", header = TRUE, sep = \"\\t\")\nrownames(res) &lt;- res$PeakID\nhead(res)\n\n           PeakID      logFC    logCPM        LR       PValue\nreg_6364 reg_6364 -1.4943851  7.812858  3.916181 4.782339e-02\nreg_6365 reg_6365 -0.3455046  8.651352  0.681276 4.091477e-01\nreg_6366 reg_6366 -3.6917987  7.187409 27.092621 1.939368e-07\nreg_6367 reg_6367 -3.9379829  7.907521 40.470868 1.995695e-10\nreg_6368 reg_6368 -1.1175852  6.537113  3.700392 5.439969e-02\nreg_6369 reg_6369 -1.7393659 12.442966 36.882154 1.254894e-09\n\nup_regions &lt;- res %&gt;%\n    dplyr::filter(logFC &gt;= 2 & PValue &lt; 0.01) %&gt;%\n    rownames()\n\nTabulate information on the proportion of enhancers in each category.\n\nlibrary(dplyr)\n# Filter the recurrence table for the significantly enriched enhancers in tumor samples and\n# select only the columns with the row-sums\n\nrec_df &lt;- recurrence_table[up_regions, ] %&gt;%\n    dplyr::select(contains(\"Called\")) %&gt;%\n    # Create a new column that group regions based on the extent of recurrence across samples\ndplyr::mutate(group = case_when(Called_Korg %in% c(1:4) ~ \"1-4\", Called_Korg %in% c(5:7) ~ \"5-7\",\n    TRUE ~ \"8-10\")) %&gt;%\n    # Aggregate regions based on the group\ndplyr::group_by(group) %&gt;%\n    dplyr::tally() %&gt;%\n    dplyr::mutate(n = as.numeric(n)) %&gt;%\n    dplyr::arrange(desc(group)) %&gt;%\n    # Calculate frequencies for each group of regions\ndplyr::mutate(prop = n/sum(n) * 100) %&gt;%\n    # Compute cumulative sum\ndplyr::mutate(cumsum = cumsum(prop)) %&gt;%\n    dplyr::mutate(ypos = cumsum(prop) - 0.5 * prop)  # To position the label at the middle of the slice \n\nDraw the plot.\n\n# Make plot\nrec_pie &lt;- ggplot(rec_df, aes(x=\"\", y=prop, fill=group)) +\n  geom_bar(stat='identity', width=1, color='white') +\n  coord_polar(\"y\", start=0, direction=1) +  # theta=variable to map angle to | start=Offset of starting point from 12 o'clock in radians | direction = clockwise or anti-clockwise.\n  theme_void() +  # try to plot without it\n  theme(legend.position=\"none\") +\n  geom_text(aes(y = ypos, label = group), color = \"white\", size=10) +\n  scale_fill_manual(values=c('orange2','coral3','red4'))\n\nrec_pie\n\n\n\n\n\n\n\n\nA pie chart is a stacked bar chart with polar coordinates (a 2D coordinate system where each point is defined by its distance from a central point (the pole) and the angle it makes with a reference line (the polar axis).\n\nTry to draw the stacked bar chart alone\n\nWe can print the frequencies as percentages, as we have calculated them in the above code.\n\nrec_df %&gt;%\n    dplyr::select(group, n, prop)\n\n\n\n\n\n\ngroup\nn\nprop\n\n\n\n\n8-10\n36\n20.45455\n\n\n5-7\n51\n28.97727\n\n\n1-4\n89\n50.56818\n\n\n\n\n\n\n\nAs we can see from the table, there is a subset of enhancers, 20% of the upregulated enhancers in chromosome 12, which are consistently highly enriched in 8-to-10 tumor organoids compared to the normal colon (10 is the total number of PDOs examined in thatstudy). This core set of regions constitute a particularly interesting signature that likely drives the regulation of relevant genes in CRC tumor cells."
  },
  {
    "objectID": "ChIP-seq_analysis/pages/ChIP-seq_analysis_part2.html#annotating-genomic-regions-to-genes",
    "href": "ChIP-seq_analysis/pages/ChIP-seq_analysis_part2.html#annotating-genomic-regions-to-genes",
    "title": "ChIP-seq_analysis_part2",
    "section": "Annotating genomic regions to genes",
    "text": "Annotating genomic regions to genes\nOne of the key steps when dealing with genomic features is their annotation to actual genes. Annotating genomic regions to genes involves the process of identifying and labeling specific regions of the genome with the genes they correspond to. This facilitates the process of understanding the genomic context of genes, including their regulation, and function.\nOne of the most reliable ways to annotate genomic regions to genes is through experimental techniques that directly measure interactions or associations between genomic elements and genes. Chromosome Conformation Capture (3C) techniques, in particular, can capture physical interactions between distant genomic regions, helping to identify enhancer-promoter interactions and other long-range interactions.\n\nAnnotating genomic regions to genes is a complex task that often requires a combination of experimental data and statistical analysis to establish associations.\n\nOften, however, it is not easy to retrieve experimental data to annotate genomic regions to genes. In such case, the best strategy is to associate these regions to nearby genes. The annotation by TSS proximity is an approximation of the reality, but nevertheless serves as a good starting point for subsequent interpretations of the functional implications derived by the annotation.\n\nFor instance, researchers may investigate how regulatory elements affect gene expression or how genetic variants within regulatory regions impact gene function.\n\n\nEnhancer distribution across known genomic features\nIn our case, the annotation to nearby TSS has already been performed using an external tool called Homer, which enables the annotation of regions to genes, but also the annotation of their genomic position with respect to relevant genomic features, like introns, exons, promoter-TSS regions, etc.\nWe will now check how our upregulated enhancers in tumor organoids are distributed across these genomic features, by plotting another pie chart.\n\n# Subset upregulated regions\ndf_anno &lt;- tumor_up_res %&gt;%\n  group_by(annotation) %&gt;% tally() %&gt;% \n  filter(annotation!='NA') %&gt;%\n  mutate(fraction = n/sum(n)) %&gt;%     # Compute percentages\n  mutate(ymax=cumsum(fraction)) %&gt;%   # Compute the cumulative percentages (top of each rectangle)\n  mutate(ymin=c(0, head(ymax, n=-1))) # Compute the bottom of each rectangle\n\ndf_anno\n\n# A tibble: 8 × 5\n  annotation       n fraction   ymax   ymin\n  &lt;chr&gt;        &lt;int&gt;    &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n1 3'              40  0.0101  0.0101 0     \n2 5'               4  0.00101 0.0111 0.0101\n3 Intergenic    2224  0.560   0.571  0.0111\n4 TTS             34  0.00856 0.579  0.571 \n5 exon            23  0.00579 0.585  0.579 \n6 intron        1605  0.404   0.989  0.585 \n7 non-coding      23  0.00579 0.995  0.989 \n8 promoter-TSS    21  0.00528 1      0.995 \n\n\n\n# Make the plot\nanno_rect &lt;- ggplot(df_anno, aes(ymax=ymax, ymin=ymin, xmax=4, xmin=3, fill=annotation)) +\n  geom_rect() +\n  coord_polar(theta=\"y\") + # Try to remove that to understand how the chart is built initially\n  xlim(c(2, 4)) + # Try to remove that to see how to make a pie chart\n  scale_fill_brewer(palette=4) \n  #theme_void()\n\n# Print plot\nanno_rect\n\n\n\n\n\n\n\n\nTry to draw the same plot as stacked barplot\n\nWhat is the genomic feature that harbors the majority of upregulated enhancer regions?"
  },
  {
    "objectID": "ChIP-seq_analysis/pages/ChIP-seq_analysis_part2.html#gene-ontology-analysis",
    "href": "ChIP-seq_analysis/pages/ChIP-seq_analysis_part2.html#gene-ontology-analysis",
    "title": "ChIP-seq_analysis_part2",
    "section": "Gene Ontology Analysis",
    "text": "Gene Ontology Analysis\nNow that we have the enhancers annotated to known human genes, we could perform a plethora of analyses in order to get other biological insights related to gene regulation. One of these is the Gene Ontology Enrichment analysis. We will try to get a more unsupervised look at what kind of biological processes are captured by the upregulated enhancers in CRC PDOs. We will do this using the gProfiler package in R.\n\nGene Ontology is a standardized system for annotating genes with terms describing their biological attributes. These terms are organized into three main categories: Molecular Function (the biochemical activity of the gene product), Biological Process (the broader biological objectives the gene contributes to), and Cellular Component (the location where the gene product is active).\n\nThe enrichment is evaluated in this way: a list of genes is compared against a background set of genes (e.g., all genes in the genome) to identify GO terms that are significantly overrepresented in the list of interest.\n\nStatistical tests, such as Fisher’s exact test or hypergeometric test, are commonly used to determine whether the observed number of genes associated with a particular GO term in the gene list is significantly higher than expected by chance.\n\nThe output of GO enrichment analysis includes a list of significantly enriched GO terms along with statistical metrics, such as p-values or false discovery rates (FDR).\n\nThis information helps to prioritize genes for further study and provides further context to the experimental results!\n\nFirst, we will create a custom function that takes as input a list of genes and automatically run the gProfiler function responsible for calulating the enrichment and also creating two plots: one that generally describes the categories of enriched terms, and another one more specific for enriched pathways from KEGG (aka, Kyoto Encyclopedia of Genes and Genomes).\n\n# Result data.frames will be stored in this object\ngprof &lt;- c()\n\n# genes: provide a character vector with gene names geneListName: a character identifying the\n# list of genes that will be used to name the data.frame stored in res and to create the pdf\n\ngprofiler &lt;- function(genes, geneListName) {\n\n    # Parameters you might want to change: ordered_query: if the gene list provided is ranked\n    # evcodes: if you want to have the gene ids that intersect between the query and the term\n    # custom_bg: the gene universe used as a background\n\n    gostres &lt;- gost(query = unique(as.character(genes)), organism = \"hsapiens\", ordered_query = FALSE,\n        multi_query = FALSE, significant = TRUE, exclude_iea = FALSE, measure_underrepresentation = FALSE,\n        evcodes = TRUE, user_threshold = 0.05, correction_method = \"g_SCS\", domain_scope = \"annotated\",\n        custom_bg = NULL, numeric_ns = \"\", sources = NULL, as_short_link = FALSE)\n\n    # Create the overview plot (not interactive)\n    gostplot &lt;- gostplot(gostres, capped = TRUE, interactive = F)\n\n    # Keep only useful columns\n    gp_mod &lt;- gostres$result[, c(\"query\", \"source\", \"term_id\", \"term_name\", \"p_value\", \"query_size\",\n        \"intersection_size\", \"term_size\", \"effective_domain_size\", \"intersection\")]\n    gp_mod$query &lt;- geneListName\n\n    # Calculate GeneRatio for the dotplot: number of genes intersecting the term/ total number\n    # of unique genes provided\n    gp_mod$GeneRatio &lt;- gp_mod$intersection_size/gp_mod$query_size\n\n    # Number of genes within the term / number of all unique genes across all terms (universe)\n    gp_mod$BgRatio &lt;- paste0(gp_mod$term_size, \"/\", gp_mod$effective_domain_size)\n\n    # Rename columns\n    names(gp_mod) &lt;- c(\"Cluster\", \"Category\", \"ID\", \"Description\", \"p.adjust\", \"query_size\", \"Intersection_size\",\n        \"term_size\", \"effective_domain_size\", \"intersection\", \"GeneRatio\", \"BgRatio\")\n\n    # Save the results data.frame in res\n    gprof[[geneListName]] &lt;&lt;- gp_mod\n\n    # Remove possible duplicate terms for plotting\n\n    gp_mod %&gt;%\n        group_by(Description) %&gt;%\n        filter(row_number() == 1)\n\n    # omit_ids &lt;- gp_mod[duplicated(gp_mod$Description), ] omit_ids_list &lt;-\n    # omit_ids$Description gp_mod &lt;- gp_mod[!gp_mod$Description %in% omit_ids_list,]\n\n    go_table_pathways &lt;- filter(gp_mod, Category %in% c(\"KEGG\"))\n\n    # Calculate negLog P-Value and rank terms based on this value\n    go_table_pathways$negLogPval = -log10(go_table_pathways$p.adjust)\n    go_table_pathways &lt;- go_table_pathways[order(-go_table_pathways$negLogPval), ]\n\n    # Make dot plot\n    dotPlot &lt;- arrange(go_table_pathways, negLogPval) %&gt;%\n        mutate(Description = factor(.$Description, levels = .$Description)) %&gt;%\n        ggplot(aes(negLogPval, Description)) + geom_point(aes(color = negLogPval, size = GeneRatio)) +\n        scale_size(range = c(5, 9)) + scale_color_gradient(low = \"blue\", high = \"red\") + theme_light() +\n        ylab(\"Pathway\") + theme(axis.text.y = element_text(size = 10), axis.text.x = element_text(size = 7),\n        legend.text = element_text(size = 7), legend.title = element_text(face = \"bold\"))\n\n    # Print on display\n    return(list(gostplot, dotPlot))\n}\n\nNow, let’s extract a vector of genes associated to the most recurrent regulatory enhancers up-regulated in tumor samples, and perform the analysis:\n\n# Extract regions with high recurrence (from all chromosomes)\nall_enh_recur &lt;- tumor_up_res %&gt;%\n    filter(padj &lt; 0.05 & log2FoldChange &gt; 0 & Called_Korg &gt;= 8)\n\n# Extract corresponding genes\ngenes_up_recur &lt;- all_enh_recur %&gt;%\n    filter(!is.na(Gene.Name)) %&gt;%\n    pull(Gene.Name) %&gt;%\n    unique()\n\nWe can check the number of genes that we have retrieved. We’ll relate this to the number of regions we start with.\n\npaste(\"Number of recurrent enhancers:\", length(all_enh_recur$PeakID))\n\n[1] \"Number of recurrent enhancers: 687\"\n\npaste(\"Number of genes associated to the recurrent enhancers:\", length(genes_up_recur))\n\n[1] \"Number of genes associated to the recurrent enhancers: 582\"\n\n\n\n💡 Can you make a consideration about the differences between the number of regions and the number of corresponding genes?\n\nWe can now run the function created above to obtain our enriched biological pathways.\n\n# Load package\nlibrary(gprofiler2)\n\n# Run custom function\ngprofiler(genes = genes_up_recur, geneListName = \"genes_up_recur\")\n\n[[1]]\n\n\n\n\n\n\n\n\n\n\n[[2]]\n\n\n\n\n\n\n\n\n\nHere, interestingly, we find that the two most enriched biological pathways are “colorectal cancer” and “Hippo signalling pathway”.\nFrom this insight we can start to generate new hypotheses, like the one tested in the study about the relevance of YAP/TAZ factors, which are indeed key downstream effectors of the Hippo signalling.\n\n💡 GO analyses might highlight very interesting patterns and generate hypotheses, but are many times quite hard to interpret depending also on the biological system we are studying.\n\nWhat information did we retrieve from the analysis?\n\ngprof$genes_up_recur %&gt;%\n    colnames()\n\n [1] \"Cluster\"               \"Category\"              \"ID\"                   \n [4] \"Description\"           \"p.adjust\"              \"query_size\"           \n [7] \"Intersection_size\"     \"term_size\"             \"effective_domain_size\"\n[10] \"intersection\"          \"GeneRatio\"             \"BgRatio\"              \n\n\n\ntable(gprof$genes_up_recur$Category)\n\n\nCORUM GO:BP GO:CC GO:MF    HP  KEGG  REAC    WP \n    1   109    17     1     1     4     1     3 \n\n\nCan you retrieve the differentially expressed genes that are part of the Hippo signaling pathway?\n\n\n[1] \"BMP4,CTNNA2,TGFBR2,GSK3B,WWTR1,AREG,TCF7,FGF1,SERPINE1,WNT16,PPP2R2A,YWHAZ\"\n\n\n\n\n[1] \"JUN,GADD45A,DCC,MAP2K2,TGFBR2,GSK3B,AREG,PIK3R1,TCF7\"\n\n\nRun enrichment analysis for regions with recurrence in at least 5/10 tumor samples\n\n\n[[1]]\n\n\n\n\n\n\n\n\n\n\n[[2]]\n\n\n\n\n\n\n\n\n\n\n# What class is gprof?\nclass(gprof)\n\n[1] \"list\"\n\n# What are the dimensions of the elements in gprof?\nlapply(gprof, dim)\n\n$genes_up_recur\n[1] 137  12\n\n$genes_up_recur5\n[1] 239  12"
  },
  {
    "objectID": "ChIP-seq_analysis/pages/ChIP-seq_analysis_part2.html#enrichment-analysis-using-gsea",
    "href": "ChIP-seq_analysis/pages/ChIP-seq_analysis_part2.html#enrichment-analysis-using-gsea",
    "title": "ChIP-seq_analysis_part2",
    "section": "Enrichment analysis using GSEA",
    "text": "Enrichment analysis using GSEA\nNormally we would perform GSEA using all regions tested for differential analysis, ranked by their padj value x log2FC sign.\nHere, we will merge the upregulated and downregulated regions and rank them based by their -log10(p-adjusted value) * the sign of the log2FoldChange, e.g. significantly upregulated genes are at the top of the rank whilst significantly downregulated ones are at the bottom. Given that we are dealing with regions and not genes, it is possible that multiple regions are annotated to the same gene. Thus, duplicate genes need to be removed from the ranking list. In doing so, we will keep the region with the most significant padj value, e.g. max(abs(padj x FC)).\nWe will retrieve gene sets from the Molecular Signatures Database (MSigDB)\n\n# Rank the genes based on their padj x sign(log2FC)\n\nranked &lt;- rbind(tumor_up_res, tumor_down_res) %&gt;%\n    select(Gene.Name, log2FoldChange, padjxFC) %&gt;%\n    filter(!Gene.Name == \"\") %&gt;%\n    mutate(abs = abs(padjxFC)) %&gt;%\n    # arrange(desc(abs)) %&gt;%\narrange(desc(padjxFC)) %&gt;%\n    group_by(Gene.Name) %&gt;%\n    filter(row_number() == 1) %&gt;%\n    # arrange(desc(padjxFC)) %&gt;% tibble::column_to_rownames('Gene.Name') %&gt;%\n    # filter(Gene.Name=='ARHGEF16')\npull(padjxFC, Gene.Name)\n\nhead(ranked)\n\nINSIG1   KRR1 PHLDA1 ACTL7B  IGFL4   SCG2 \n21.093 17.403 16.816 15.909 15.447 14.599 \n\ntail(ranked)\n\n    FAM90A26        UBE2K LOC101928269         MRC2       SNAR-I           GC \n     -12.327      -12.395      -13.549      -13.684      -13.886      -14.254 \n\n\nInstall and import libraries for fgsea and msigdbr\n\nif (!require(fgsea, quiet = TRUE)) BiocManager::install(\"fgsea\")\n\n\nif (!require(msigdbr, quiet = TRUE)) install.packages(\"msigdbr\")\n\nExtract the curated gene sets (C2) from the MSigDB database\n\nlibrary(msigdbr)\n# Extract specific gene sets from the MSigDB database\ncurated_gsets &lt;- msigdbr(species = \"human\", category = \"C2\", subcategory = \"CGP\")\n\nInspect the information and gene sets we retrieved.\n\nnames(curated_gsets)\n\n [1] \"gene_symbol\"        \"ncbi_gene\"          \"ensembl_gene\"      \n [4] \"db_gene_symbol\"     \"db_ncbi_gene\"       \"db_ensembl_gene\"   \n [7] \"source_gene\"        \"gs_id\"              \"gs_name\"           \n[10] \"gs_collection\"      \"gs_subcollection\"   \"gs_collection_name\"\n[13] \"gs_description\"     \"gs_source_species\"  \"gs_pmid\"           \n[16] \"gs_geoid\"           \"gs_exact_source\"    \"gs_url\"            \n[19] \"db_version\"         \"db_target_species\"  \"entrez_gene\"       \n[22] \"gs_cat\"             \"gs_subcat\"         \n\ncurated_gsets %&gt;%\n    pull(gs_name) %&gt;%\n    unique() %&gt;%\n    head(2)\n\n[1] \"ABBUD_LIF_SIGNALING_1_DN\" \"ABBUD_LIF_SIGNALING_1_UP\"\n\n\nCheck if there are any gene sets related to Colon Cancer.\n\ncurated_gsets %&gt;%\n    filter(grepl(\"COLON_AND_RECTAL\", gs_name)) %&gt;%\n    head()\n\n  gene_symbol ncbi_gene    ensembl_gene db_gene_symbol db_ncbi_gene\n1       ACTL8     81569 ENSG00000117148          ACTL8        81569\n2    ADAMTSL4     54507 ENSG00000143382       ADAMTSL4        54507\n3      AKR7A2      8574 ENSG00000053371         AKR7A2         8574\n4        AOC2       314 ENSG00000131480           AOC2          314\n5    B3GALNT1      8706 ENSG00000169255       B3GALNT1         8706\n6   C14orf132     56967 ENSG00000227051      C14orf132        56967\n  db_ensembl_gene source_gene  gs_id                          gs_name\n1 ENSG00000117148    LOC81569 M15780 GRADE_COLON_AND_RECTAL_CANCER_DN\n2 ENSG00000143382       TSRC1 M15780 GRADE_COLON_AND_RECTAL_CANCER_DN\n3 ENSG00000053371      AKR7A2 M15780 GRADE_COLON_AND_RECTAL_CANCER_DN\n4 ENSG00000131480        AOC2 M15780 GRADE_COLON_AND_RECTAL_CANCER_DN\n5 ENSG00000169255     B3GALT3 M15780 GRADE_COLON_AND_RECTAL_CANCER_DN\n6 ENSG00000227051   C14orf132 M15780 GRADE_COLON_AND_RECTAL_CANCER_DN\n  gs_collection gs_subcollection                 gs_collection_name\n1            C2              CGP Chemical and Genetic Perturbations\n2            C2              CGP Chemical and Genetic Perturbations\n3            C2              CGP Chemical and Genetic Perturbations\n4            C2              CGP Chemical and Genetic Perturbations\n5            C2              CGP Chemical and Genetic Perturbations\n6            C2              CGP Chemical and Genetic Perturbations\n                                                                              gs_description\n1 Down-regulated genes in both rectal and colon carcinoma compared to normal mucosa samples.\n2 Down-regulated genes in both rectal and colon carcinoma compared to normal mucosa samples.\n3 Down-regulated genes in both rectal and colon carcinoma compared to normal mucosa samples.\n4 Down-regulated genes in both rectal and colon carcinoma compared to normal mucosa samples.\n5 Down-regulated genes in both rectal and colon carcinoma compared to normal mucosa samples.\n6 Down-regulated genes in both rectal and colon carcinoma compared to normal mucosa samples.\n  gs_source_species  gs_pmid gs_geoid                  gs_exact_source gs_url\n1                HS 17210682          Table 5S: Colon &lt; 1 & Rectum &lt; 1       \n2                HS 17210682          Table 5S: Colon &lt; 1 & Rectum &lt; 1       \n3                HS 17210682          Table 5S: Colon &lt; 1 & Rectum &lt; 1       \n4                HS 17210682          Table 5S: Colon &lt; 1 & Rectum &lt; 1       \n5                HS 17210682          Table 5S: Colon &lt; 1 & Rectum &lt; 1       \n6                HS 17210682          Table 5S: Colon &lt; 1 & Rectum &lt; 1       \n  db_version db_target_species entrez_gene gs_cat gs_subcat\n1  2024.1.Hs                HS       81569     C2       CGP\n2  2024.1.Hs                HS       54507     C2       CGP\n3  2024.1.Hs                HS        8574     C2       CGP\n4  2024.1.Hs                HS         314     C2       CGP\n5  2024.1.Hs                HS        8706     C2       CGP\n6  2024.1.Hs                HS       56967     C2       CGP\n\n\n\n# Filter the curated gene sets for the gene set of our interest\ngene_set_name &lt;- c(\"GRADE_COLON_AND_RECTAL_CANCER_UP\", \"GRADE_COLON_AND_RECTAL_CANCER_DN\")\ntex_sig_df &lt;- curated_gsets %&gt;%\n    filter(gs_name %in% gene_set_name)\nhead(tex_sig_df, 2)\n\n  gene_symbol ncbi_gene    ensembl_gene db_gene_symbol db_ncbi_gene\n1       ACTL8     81569 ENSG00000117148          ACTL8        81569\n2    ADAMTSL4     54507 ENSG00000143382       ADAMTSL4        54507\n  db_ensembl_gene source_gene  gs_id                          gs_name\n1 ENSG00000117148    LOC81569 M15780 GRADE_COLON_AND_RECTAL_CANCER_DN\n2 ENSG00000143382       TSRC1 M15780 GRADE_COLON_AND_RECTAL_CANCER_DN\n  gs_collection gs_subcollection                 gs_collection_name\n1            C2              CGP Chemical and Genetic Perturbations\n2            C2              CGP Chemical and Genetic Perturbations\n                                                                              gs_description\n1 Down-regulated genes in both rectal and colon carcinoma compared to normal mucosa samples.\n2 Down-regulated genes in both rectal and colon carcinoma compared to normal mucosa samples.\n  gs_source_species  gs_pmid gs_geoid                  gs_exact_source gs_url\n1                HS 17210682          Table 5S: Colon &lt; 1 & Rectum &lt; 1       \n2                HS 17210682          Table 5S: Colon &lt; 1 & Rectum &lt; 1       \n  db_version db_target_species entrez_gene gs_cat gs_subcat\n1  2024.1.Hs                HS       81569     C2       CGP\n2  2024.1.Hs                HS       54507     C2       CGP\n\n\nWe will prepare a gene set list retrieving the genes that are contained in each gene set (shown in the gs_name column).\n\n# Create an empty gene set list\ngset &lt;- list()\n\n# For each gene set in the data frame retrieve the gene symbols and store them in the gset\n# list.\n\nfor (gs in unique(tex_sig_df$gs_name)) {\n\n    # subset the table for a gene set\n    tmp &lt;- tex_sig_df %&gt;%\n        filter(gs_name == gs)\n\n    # retrieve gene symbols\n    tmp_gset &lt;- list(tmp$gene_symbol)\n    # names(tmp_gset) &lt;- gene_set_name\n\n    # add the genes in the gset list\n    gset[gs] &lt;- tmp_gset\n}\n\nlapply(gset, length)\n\n$GRADE_COLON_AND_RECTAL_CANCER_DN\n[1] 102\n\n$GRADE_COLON_AND_RECTAL_CANCER_UP\n[1] 291\n\ngset\n\n$GRADE_COLON_AND_RECTAL_CANCER_DN\n  [1] \"ACTL8\"      \"ADAMTSL4\"   \"AKR7A2\"     \"AOC2\"       \"B3GALNT1\"  \n  [6] \"C14orf132\"  \"C2orf88\"    \"CA5A\"       \"CACNA2D2\"   \"CBS\"       \n [11] \"CCDC71\"     \"CCR9\"       \"CD28\"       \"CDK12\"      \"CFD\"       \n [16] \"CHST15\"     \"CHST8\"      \"COL4A5\"     \"CPN2\"       \"CX3CR1\"    \n [21] \"CYB5D1\"     \"DAP\"        \"DHPS\"       \"FABP7\"      \"FAN1\"      \n [26] \"FHL1\"       \"FKRP\"       \"GFI1\"       \"GGA1\"       \"GNA11\"     \n [31] \"GNPDA1\"     \"GPC1\"       \"GPR87\"      \"GREB1\"      \"GTF3C4\"    \n [36] \"HAUS5\"      \"HIC2\"       \"HMGXB4\"     \"ITPKB\"      \"JAM3\"      \n [41] \"KRT84\"      \"LDB2\"       \"LGALS2\"     \"LRFN1\"      \"LRTOMT\"    \n [46] \"LYPD3\"      \"MEF2D\"      \"MITF\"       \"MSRA\"       \"MYCN\"      \n [51] \"NAT8L\"      \"NAV1\"       \"NR1H4\"      \"NR3C1\"      \"NUDT11\"    \n [56] \"OSGIN2\"     \"PARM1\"      \"PARVB\"      \"PCDHB5\"     \"PDK4\"      \n [61] \"PGC\"        \"PLAC8\"      \"PLD1\"       \"PLPP1\"      \"PRKACB\"    \n [66] \"PRRT2\"      \"PTPRZ1\"     \"RERE\"       \"SASH1\"      \"SCAMP5\"    \n [71] \"SERTAD4\"    \"SESN2\"      \"SIRPB1\"     \"SIX1\"       \"SLC16A9\"   \n [76] \"SLC30A3\"    \"SLC30A6\"    \"SMIM14\"     \"SNCA\"       \"SOCS2\"     \n [81] \"SPIN4\"      \"ST6GALNAC6\" \"STAR\"       \"STAT5A\"     \"SYNC\"      \n [86] \"TBC1D27P\"   \"TGFBR3\"     \"TIMM22\"     \"TLE4\"       \"TLN2\"      \n [91] \"TM9SF1\"     \"TOX2\"       \"TRPS1\"      \"TYRP1\"      \"UBAP1\"     \n [96] \"UGDH\"       \"UNC5B\"      \"XPNPEP3\"    \"YY1AP1\"     \"ZBTB4\"     \n[101] \"ZNF135\"     \"ZNF787\"    \n\n$GRADE_COLON_AND_RECTAL_CANCER_UP\n  [1] \"AAMP\"      \"AARS1\"     \"ABCB8\"     \"ABCF1\"     \"ACBD6\"     \"ADGRG1\"   \n  [7] \"AHCY\"      \"ALG1\"      \"AMPD3\"     \"ANXA5\"     \"ATIC\"      \"ATP6AP2\"  \n [13] \"AURKA\"     \"AZGP1\"     \"BACE2\"     \"BORA\"      \"BPHL\"      \"C4BPB\"    \n [19] \"CAMSAP1\"   \"CARHSP1\"   \"CCDC191\"   \"CCDC85B\"   \"CCDC92\"    \"CCNB1\"    \n [25] \"CCT5\"      \"CCT7\"      \"CCT8\"      \"CD44\"      \"CD46\"      \"CDC25B\"   \n [31] \"CDC45\"     \"CDC6\"      \"CDCA7\"     \"CDK1\"      \"CDK7\"      \"CEP57L1\"  \n [37] \"CFB\"       \"CHCHD2\"    \"CKS2\"      \"CNBP\"      \"COL4A1\"    \"COPS8\"    \n [43] \"CSNK1E\"    \"CSTF1\"     \"CTSB\"      \"DAP3\"      \"DCAF7\"     \"DDIT4\"    \n [49] \"DDX1\"      \"DDX27\"     \"DDX39A\"    \"DDX39B\"    \"DEF8\"      \"DGAT2\"    \n [55] \"DHX8\"      \"DHX9\"      \"DNAJA3\"    \"DNAJC2\"    \"DNTTIP1\"   \"DOLK\"     \n [61] \"DPM1\"      \"DPY19L1\"   \"DRG1\"      \"DUSP18\"    \"EEF1E1\"    \"EFTUD2\"   \n [67] \"EIF2S2\"    \"EIF3B\"     \"EIF3E\"     \"EIF4A1\"    \"EIF4B\"     \"EIF6\"     \n [73] \"EMC8\"      \"ENG\"       \"EPHB2\"     \"EPRS1\"     \"ERI1\"      \"ETS2\"     \n [79] \"ETV4\"      \"EXOC2\"     \"FAM210B\"   \"FBL\"       \"FBXO11\"    \"FDFT1\"    \n [85] \"FERMT1\"    \"FXYD5\"     \"GARS1\"     \"GCLC\"      \"GCSH\"      \"GDF15\"    \n [91] \"GEMIN6\"    \"GLO1\"      \"GPSM2\"     \"GSK3B\"     \"GTF2F2\"    \"GTF3A\"    \n [97] \"GTPBP10\"   \"GYG2\"      \"H2AZ1\"     \"HELLS\"     \"HILPDA\"    \"HJURP\"    \n[103] \"HM13\"      \"HMGB1\"     \"HMGB2\"     \"HNRNPA1\"   \"HNRNPA2B1\" \"HNRNPD\"   \n[109] \"HNRNPK\"    \"HOXB5\"     \"HSPA4\"     \"HSPA9\"     \"HSPE1\"     \"ICA1\"     \n[115] \"IFITM1\"    \"IFRD1\"     \"INTS7\"     \"IRAK1\"     \"ITGB5\"     \"KARS1\"    \n[121] \"KBTBD2\"    \"KIF23\"     \"KNTC1\"     \"KPNA3\"     \"L1CAM\"     \"LAMP1\"    \n[127] \"LAPTM4B\"   \"LDHA\"      \"LDHB\"      \"LRP8\"      \"LST1\"      \"LY6E\"     \n[133] \"LYAR\"      \"MACROH2A1\" \"MAGED2\"    \"MARS1\"     \"MBTPS2\"    \"MCM2\"     \n[139] \"MCM3\"      \"MCM4\"      \"MCM5\"      \"MCM7\"      \"MDC1\"      \"MELK\"     \n[145] \"METTL2B\"   \"METTL3\"    \"METTL5\"    \"MKLN1\"     \"MLST8\"     \"MRGBP\"    \n[151] \"MRPL17\"    \"MRPL3\"     \"MRPL9\"     \"MTHFD1\"    \"MTHFD2\"    \"MYC\"      \n[157] \"NAA10\"     \"NDUFAF7\"   \"NEBL\"      \"NIP7\"      \"NIT2\"      \"NMI\"      \n[163] \"NOB1\"      \"NOL8\"      \"NONO\"      \"NOP56\"     \"NPM1\"      \"NQO2\"     \n[169] \"NSMCE2\"    \"NUSAP1\"    \"OLA1\"      \"OSER1\"     \"PA2G4\"     \"PABPC3\"   \n[175] \"PAFAH1B3\"  \"PCNA\"      \"PDCD2L\"    \"PDCD6\"     \"PDK3\"      \"PDXK\"     \n[181] \"PERP\"      \"PFDN2\"     \"PKM\"       \"PLAAT3\"    \"PLAU\"      \"PLCB4\"    \n[187] \"PLK1\"      \"PMPCB\"     \"PNPO\"      \"PNPT1\"     \"POFUT1\"    \"POLD2\"    \n[193] \"POLQ\"      \"POLR1D\"    \"POLR2D\"    \"POMP\"      \"PPA1\"      \"PPIA\"     \n[199] \"PRDX1\"     \"PRDX4\"     \"PRKDC\"     \"PSMA1\"     \"PSMA2\"     \"PSMA3\"    \n[205] \"PSMB1\"     \"PSMB3\"     \"PSMB7\"     \"PSMD14\"    \"PSMD4\"     \"PSMG1\"    \n[211] \"PTCD3\"     \"PTDSS1\"    \"PTPN12\"    \"PXDN\"      \"RAB4B\"     \"RAN\"      \n[217] \"RBM26\"     \"RCC1\"      \"RCN1\"      \"RFC2\"      \"RFC5\"      \"RHEB\"     \n[223] \"RLIM\"      \"RMI2\"      \"RRM1\"      \"RRM2\"      \"RTF2\"      \"RTKN\"     \n[229] \"S100A14\"   \"SAP18\"     \"SEPHS1\"    \"SERPINB5\"  \"SET\"       \"SFT2D3\"   \n[235] \"SH3GL1\"    \"SHISA5\"    \"SKA3\"      \"SLC12A2\"   \"SMPD4\"     \"SNRPB\"    \n[241] \"SOD2\"      \"SOX9\"      \"SPARC\"     \"SPATA13\"   \"SPATA13\"   \"SPP1\"     \n[247] \"SRP72\"     \"SRSF1\"     \"SRSF2\"     \"SSB\"       \"SSRP1\"     \"SYAP1\"    \n[253] \"SYNCRIP\"   \"TALDO1\"    \"TARS1\"     \"TBCE\"      \"TCF7\"      \"TFB1M\"    \n[259] \"TGDS\"      \"TGFBI\"     \"THEM6\"     \"THOC3\"     \"THY1\"      \"TIMELESS\" \n[265] \"TIMP1\"     \"TKT\"       \"TMEM97\"    \"TMSB4Y\"    \"TPI1\"      \"TRAF5\"    \n[271] \"TRAP1\"     \"TRUB2\"     \"TTPAL\"     \"UBD\"       \"UBE2N\"     \"UBR4\"     \n[277] \"URI1\"      \"USP7\"      \"USP9X\"     \"UTP11\"     \"VBP1\"      \"VEGFA\"    \n[283] \"VKORC1L1\"  \"WDR74\"     \"WDR75\"     \"XRN2\"      \"ZDHHC9\"    \"ZFAND1\"   \n[289] \"ZMYND8\"    \"ZNF84\"     \"ZNG1B\"    \n\n\nRun GSEA on our ranked list of genes using the gene sets we retrieve from MSigDB. Here, we set the number of permutations to 1000.\n\nlibrary(fgsea)\n# Run GSEA\nfgseaRes &lt;- fgsea(pathways = gset, stats = ranked, nperm = 1000)\n\nInspect the results\n\n# Take a look at results\nfgseaRes\n\n                            pathway       pval       padj        ES       NES\n                             &lt;char&gt;      &lt;num&gt;      &lt;num&gt;     &lt;num&gt;     &lt;num&gt;\n1: GRADE_COLON_AND_RECTAL_CANCER_DN 0.51590106 0.51590106 0.2120043 0.9689386\n2: GRADE_COLON_AND_RECTAL_CANCER_UP 0.02792321 0.05584642 0.3032790 1.5503333\n   nMoreExtreme  size  leadingEdge\n          &lt;num&gt; &lt;int&gt;       &lt;list&gt;\n1:          291    41 CHST15, ....\n2:           15    66 PLAU, TC....\n\n\nPlot GSEA results\n\n# Plot GSEA results\n\nfor (gs in unique(gene_set_name)) {\n    print(plotEnrichment(gset[[gs]], ranked) + labs(title = gs))\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCan you retrieve the leading edge genes from the reuslts?"
  },
  {
    "objectID": "ChIP-seq_analysis/pages/ChIP-seq_analysis_part2.html#region-annotation-with-chippeakanno",
    "href": "ChIP-seq_analysis/pages/ChIP-seq_analysis_part2.html#region-annotation-with-chippeakanno",
    "title": "ChIP-seq_analysis_part2",
    "section": "Region annotation with ChIPpeakAnno",
    "text": "Region annotation with ChIPpeakAnno\nWe will try an alternative approach to annotate our enhancer regions leveraging the BioConductor package ChIPpeakAnno. First we create a GRanges object of the upregulated regions.\n\nup.gr &lt;- makeGRangesFromDataFrame(tumor_up_res, keep.extra.columns = TRUE)\nup.gr\n\nGRanges object with 3974 ranges and 15 metadata columns:\n         seqnames              ranges strand |      PeakID       deseq\n            &lt;Rle&gt;           &lt;IRanges&gt;  &lt;Rle&gt; | &lt;character&gt; &lt;character&gt;\n     [1]     chr1     3291000-3294200      * |      reg_56    deseq_up\n     [2]     chr1     3328800-3331400      * |      reg_58    deseq_up\n     [3]     chr1     3494000-3496400      * |      reg_66    deseq_up\n     [4]     chr1     3509400-3511000      * |      reg_68    deseq_up\n     [5]     chr1     3513400-3515200      * |      reg_69    deseq_up\n     ...      ...                 ...    ... .         ...         ...\n  [3970]     chrX 151896800-151898400      * |   reg_33047    deseq_up\n  [3971]     chrX 151900600-151904600      * |   reg_33048    deseq_up\n  [3972]     chrX 154368400-154369200      * |   reg_33071    deseq_up\n  [3973]     chrY     9176000-9177600      * |   reg_33097    deseq_up\n  [3974]     chrY     9278000-9279800      * |   reg_33099    deseq_up\n          baseMean log2FoldChange     lfcSE      stat      pvalue        padj\n         &lt;numeric&gt;      &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt;   &lt;numeric&gt;   &lt;numeric&gt;\n     [1]  11.53169        3.68190  0.775310   4.74894 2.04489e-06 4.04021e-05\n     [2]  11.22958        1.93821  0.735416   2.63553 8.40071e-03 2.66628e-02\n     [3]   8.20774        2.49910  1.033260   2.41865 1.55780e-02 4.27478e-02\n     [4]   6.61575        2.98599  0.956157   3.12290 1.79076e-03 8.15651e-03\n     [5]   6.80467        4.30521  1.071856   4.01659 5.90454e-05 5.82429e-04\n     ...       ...            ...       ...       ...         ...         ...\n  [3970]   7.35329        3.39137  0.880766   3.85047 0.000117890 0.000998584\n  [3971]  16.29193        2.19479  0.765732   2.86627 0.004153423 0.015505174\n  [3972]   4.58607        2.22117  0.882322   2.51741 0.011821996 0.034497587\n  [3973]   3.78489        3.39099  1.217671   2.78482 0.005355755 0.018851664\n  [3974]   6.76525        4.25332  1.267348   3.35608 0.000790553 0.004332179\n           padjxFC                 region  annotation   Gene.Name\n         &lt;numeric&gt;            &lt;character&gt; &lt;character&gt; &lt;character&gt;\n     [1]     4.394   chr1:3291000-3294200      intron    ARHGEF16\n     [2]     1.574   chr1:3328800-3331400      intron    ARHGEF16\n     [3]     1.369   chr1:3494000-3496400      intron    ARHGEF16\n     [4]     2.088   chr1:3509400-3511000      intron     MIR551A\n     [5]     3.235   chr1:3513400-3515200      intron     MIR551A\n     ...       ...                    ...         ...         ...\n  [3970]     3.001 chrX:151896800-15189..  Intergenic  MAGEA4-AS1\n  [3971]     1.810 chrX:151900600-15190..  Intergenic  MAGEA4-AS1\n  [3972]     1.462 chrX:154368400-15436..      intron        FLNA\n  [3973]     1.725   chrY:9176000-9177600  Intergenic    RBMY1A3P\n  [3974]     2.363   chrY:9278000-9279800  Intergenic    RBMY1A3P\n              Gene.Type Called_Korg Called_Ncr\n            &lt;character&gt;   &lt;integer&gt;  &lt;integer&gt;\n     [1] protein-coding           4          0\n     [2] protein-coding           4          0\n     [3] protein-coding           2          0\n     [4]          ncRNA           2          0\n     [5]          ncRNA           2          0\n     ...            ...         ...        ...\n  [3970]          ncRNA           3          0\n  [3971]          ncRNA           5          0\n  [3972] protein-coding           2          0\n  [3973]         pseudo           2          0\n  [3974]         pseudo           3          0\n  -------\n  seqinfo: 24 sequences from an unspecified genome; no seqlengths\n\n\n\n# Load the library\n\n# if (!require(ChIPpeakAnno)) BiocManager::install('ChIPpeakAnno')\n\nlibrary(ChIPpeakAnno)\n\nTo perform the annotation we need to incorporate information on gene structure and positions. We will import the annotation package for human assembly hg38 version 86 from Ensembl.\n\n# Use Ensembl annotation package: if (!require(EnsDb.Hsapiens.v86))\n# BiocManager::install('EnsDb.Hsapiens.v86')\nlibrary(EnsDb.Hsapiens.v86)\n\n# ensembl.hs86.transcript &lt;- transcripts(EnsDb.Hsapiens.v86)\nensembl.hs86.gene &lt;- genes(EnsDb.Hsapiens.v86)\n\n\n# Use Ensembl annotation package:\nup_peak_ensembl &lt;- annotatePeakInBatch(up.gr, AnnotationData = ensembl.hs86.gene)\nhead(up_peak_ensembl, n = 2)\n\nGRanges object with 2 ranges and 24 metadata columns:\n                        seqnames          ranges strand |      PeakID\n                           &lt;Rle&gt;       &lt;IRanges&gt;  &lt;Rle&gt; | &lt;character&gt;\n  X0001.ENSG00000272235     chr1 3291000-3294200      * |      reg_56\n  X0002.ENSG00000272235     chr1 3328800-3331400      * |      reg_58\n                              deseq  baseMean log2FoldChange     lfcSE\n                        &lt;character&gt; &lt;numeric&gt;      &lt;numeric&gt; &lt;numeric&gt;\n  X0001.ENSG00000272235    deseq_up   11.5317        3.68190  0.775310\n  X0002.ENSG00000272235    deseq_up   11.2296        1.93821  0.735416\n                             stat      pvalue        padj   padjxFC\n                        &lt;numeric&gt;   &lt;numeric&gt;   &lt;numeric&gt; &lt;numeric&gt;\n  X0001.ENSG00000272235   4.74894 2.04489e-06 4.04021e-05     4.394\n  X0002.ENSG00000272235   2.63553 8.40071e-03 2.66628e-02     1.574\n                                      region  annotation   Gene.Name\n                                 &lt;character&gt; &lt;character&gt; &lt;character&gt;\n  X0001.ENSG00000272235 chr1:3291000-3294200      intron    ARHGEF16\n  X0002.ENSG00000272235 chr1:3328800-3331400      intron    ARHGEF16\n                             Gene.Type Called_Korg Called_Ncr        peak\n                           &lt;character&gt;   &lt;integer&gt;  &lt;integer&gt; &lt;character&gt;\n  X0001.ENSG00000272235 protein-coding           4          0        0001\n  X0002.ENSG00000272235 protein-coding           4          0        0002\n                                feature start_position end_position\n                            &lt;character&gt;      &lt;integer&gt;    &lt;integer&gt;\n  X0001.ENSG00000272235 ENSG00000272235        3306636      3310096\n  X0002.ENSG00000272235 ENSG00000272235        3306636      3310096\n                        feature_strand insideFeature distancetoFeature\n                           &lt;character&gt;   &lt;character&gt;         &lt;numeric&gt;\n  X0001.ENSG00000272235              -    downstream             19096\n  X0002.ENSG00000272235              -      upstream            -18704\n                        shortestDistance fromOverlappingOrNearest\n                               &lt;integer&gt;              &lt;character&gt;\n  X0001.ENSG00000272235            12436          NearestLocation\n  X0002.ENSG00000272235            18704          NearestLocation\n  -------\n  seqinfo: 24 sequences from an unspecified genome; no seqlengths\n\n\nWe can now annotate the Ensembl IDs with the corresponding gene symbols. Here, we will use the org.Hs.eg.db database.\n\nif (!require(\"org.Hs.eg.db\", quietly = TRUE)) BiocManager::install(\"org.Hs.eg.db\")\n\n\nlibrary(org.Hs.eg.db)\n# Use Ensembl annotation package:\nup_peak_ensembl &lt;- addGeneIDs(annotatedPeak = up_peak_ensembl, \n                                orgAnn = \"org.Hs.eg.db\",\n                                #mart = mart,\n                                feature_id_type = \"ensembl_gene_id\",\n                                IDs2Add = \"symbol\")\n\nhead(up_peak_ensembl, n = 2)\n\nGRanges object with 2 ranges and 25 metadata columns:\n                        seqnames          ranges strand |      PeakID\n                           &lt;Rle&gt;       &lt;IRanges&gt;  &lt;Rle&gt; | &lt;character&gt;\n  X0001.ENSG00000272235     chr1 3291000-3294200      * |      reg_56\n  X0002.ENSG00000272235     chr1 3328800-3331400      * |      reg_58\n                              deseq  baseMean log2FoldChange     lfcSE\n                        &lt;character&gt; &lt;numeric&gt;      &lt;numeric&gt; &lt;numeric&gt;\n  X0001.ENSG00000272235    deseq_up   11.5317        3.68190  0.775310\n  X0002.ENSG00000272235    deseq_up   11.2296        1.93821  0.735416\n                             stat      pvalue        padj   padjxFC\n                        &lt;numeric&gt;   &lt;numeric&gt;   &lt;numeric&gt; &lt;numeric&gt;\n  X0001.ENSG00000272235   4.74894 2.04489e-06 4.04021e-05     4.394\n  X0002.ENSG00000272235   2.63553 8.40071e-03 2.66628e-02     1.574\n                                      region  annotation   Gene.Name\n                                 &lt;character&gt; &lt;character&gt; &lt;character&gt;\n  X0001.ENSG00000272235 chr1:3291000-3294200      intron    ARHGEF16\n  X0002.ENSG00000272235 chr1:3328800-3331400      intron    ARHGEF16\n                             Gene.Type Called_Korg Called_Ncr        peak\n                           &lt;character&gt;   &lt;integer&gt;  &lt;integer&gt; &lt;character&gt;\n  X0001.ENSG00000272235 protein-coding           4          0        0001\n  X0002.ENSG00000272235 protein-coding           4          0        0002\n                                feature start_position end_position\n                            &lt;character&gt;      &lt;integer&gt;    &lt;integer&gt;\n  X0001.ENSG00000272235 ENSG00000272235        3306636      3310096\n  X0002.ENSG00000272235 ENSG00000272235        3306636      3310096\n                        feature_strand insideFeature distancetoFeature\n                           &lt;character&gt;   &lt;character&gt;         &lt;numeric&gt;\n  X0001.ENSG00000272235              -    downstream             19096\n  X0002.ENSG00000272235              -      upstream            -18704\n                        shortestDistance fromOverlappingOrNearest      symbol\n                               &lt;integer&gt;              &lt;character&gt; &lt;character&gt;\n  X0001.ENSG00000272235            12436          NearestLocation        &lt;NA&gt;\n  X0002.ENSG00000272235            18704          NearestLocation        &lt;NA&gt;\n  -------\n  seqinfo: 24 sequences from an unspecified genome; no seqlengths\n\n\nCompare the annotation we got from HOMER (Gene.Name column) to the annotation from ChIPpeakAnno (symbol column). You can generate a data.frame object for better visualization.\n\nup_peak_ensembl %&gt;%\n    dplyr::select(region, annotation, Gene.Name, symbol)\n\nGRanges object with 3990 ranges and 4 metadata columns:\n                        seqnames              ranges strand |\n                           &lt;Rle&gt;           &lt;IRanges&gt;  &lt;Rle&gt; |\n  X0001.ENSG00000272235     chr1     3291000-3294200      * |\n  X0002.ENSG00000272235     chr1     3328800-3331400      * |\n  X0003.ENSG00000272088     chr1     3494000-3496400      * |\n  X0004.ENSG00000272088     chr1     3509400-3511000      * |\n  X0005.ENSG00000272088     chr1     3513400-3515200      * |\n                    ...      ...                 ...    ... .\n  X3970.ENSG00000147381     chrX 151896800-151898400      * |\n  X3971.ENSG00000147381     chrX 151900600-151904600      * |\n  X3972.ENSG00000196924     chrX 154368400-154369200      * |\n  X3973.ENSG00000224408     chrY     9176000-9177600      * |\n  X3974.ENSG00000197038     chrY     9278000-9279800      * |\n                                        region  annotation   Gene.Name\n                                   &lt;character&gt; &lt;character&gt; &lt;character&gt;\n  X0001.ENSG00000272235   chr1:3291000-3294200      intron    ARHGEF16\n  X0002.ENSG00000272235   chr1:3328800-3331400      intron    ARHGEF16\n  X0003.ENSG00000272088   chr1:3494000-3496400      intron    ARHGEF16\n  X0004.ENSG00000272088   chr1:3509400-3511000      intron     MIR551A\n  X0005.ENSG00000272088   chr1:3513400-3515200      intron     MIR551A\n                    ...                    ...         ...         ...\n  X3970.ENSG00000147381 chrX:151896800-15189..  Intergenic  MAGEA4-AS1\n  X3971.ENSG00000147381 chrX:151900600-15190..  Intergenic  MAGEA4-AS1\n  X3972.ENSG00000196924 chrX:154368400-15436..      intron        FLNA\n  X3973.ENSG00000224408   chrY:9176000-9177600  Intergenic    RBMY1A3P\n  X3974.ENSG00000197038   chrY:9278000-9279800  Intergenic    RBMY1A3P\n                             symbol\n                        &lt;character&gt;\n  X0001.ENSG00000272235        &lt;NA&gt;\n  X0002.ENSG00000272235        &lt;NA&gt;\n  X0003.ENSG00000272088        &lt;NA&gt;\n  X0004.ENSG00000272088        &lt;NA&gt;\n  X0005.ENSG00000272088        &lt;NA&gt;\n                    ...         ...\n  X3970.ENSG00000147381      MAGEA4\n  X3971.ENSG00000147381      MAGEA4\n  X3972.ENSG00000196924        FLNA\n  X3973.ENSG00000224408        &lt;NA&gt;\n  X3974.ENSG00000197038        &lt;NA&gt;\n  -------\n  seqinfo: 24 sequences from an unspecified genome; no seqlengths\n\n\n\nWhy do you think there are differences in the annotation?"
  },
  {
    "objectID": "ChIP-seq_analysis/pages/ChIP-seq_analysis_part2.html#take-home-messages",
    "href": "ChIP-seq_analysis/pages/ChIP-seq_analysis_part2.html#take-home-messages",
    "title": "ChIP-seq_analysis_part2",
    "section": "Take-home Messages 🏠",
    "text": "Take-home Messages 🏠\nCongratulations! You got the end of the course and now hopefully know some crucial aspects of a ChIP-seq analysis workflow! Some of the key concepts that we have explored during the course can enable us to reach some distilled points of interest:\n\nDesign your experiments carefully with data analysis in mind!\nData needs to be carefully explored to avoid systematic errors in the analyses!\nPlot and Visualize as much as possible!\nNot all information is useful, remember that it all depends on the biological question!\nOmics outputs are immensely rich and one experiment can be used to answer a plethora of questions!"
  },
  {
    "objectID": "ChIP-seq_analysis/pages/ChIP-seq_principles.html",
    "href": "ChIP-seq_analysis/pages/ChIP-seq_principles.html",
    "title": "ChIP-seq_workflow",
    "section": "",
    "text": "In this context, we chose to deal with a Chromatin Immuno-precipitation (ChIP from now on) assay. \n\n💭 Suppose you have found an interesting, new histone variant, and managed to produce a strong antibody against it. You want to know where it’s located in the genome of your cells of interest (say, tumor cells), to start deducing its function.\n\nChIP, coupled to sequencing (ChIP-seq), allows you to approach the question, genome-wide.\nIt works by extracting chromatin (DNA bound to protein), fragmenting it, and selecting the protein or protein variant of interest from this complex mixture with an antibody in some way specific for it. The subset of genome you will have isolated will constitute the sequences you expect your variant to bind, informing your inferences regarding its function.\n\nChIP-seq use in mapping histone modifications has been seminal in epigenetics research! (Ku et al., 2011)\n\nHere you can see a recap of the major steps:\n+ Cross-linking: add Formaldehyde\n+ Cell lysis (breakdown of cell membranes)\n+ Fragmentation of DNA fragments (shearing), e.g. digestion with specific endonuclease enzymes (dpn1) or sonication\n+ Addition of specific bead-coupled antibody against the protein of interest, separating it from the mixture\n+ Separate DNA from the protein (reverse cross-linking), and DNA purification\n+ DNA fragment amplification, library construction\n+ Library sequencing by NGS (essentially Illumina)"
  },
  {
    "objectID": "ChIP-seq_analysis/pages/ChIP-seq_principles.html#the-chip-seq-technology",
    "href": "ChIP-seq_analysis/pages/ChIP-seq_principles.html#the-chip-seq-technology",
    "title": "ChIP-seq_workflow",
    "section": "",
    "text": "In this context, we chose to deal with a Chromatin Immuno-precipitation (ChIP from now on) assay. \n\n💭 Suppose you have found an interesting, new histone variant, and managed to produce a strong antibody against it. You want to know where it’s located in the genome of your cells of interest (say, tumor cells), to start deducing its function.\n\nChIP, coupled to sequencing (ChIP-seq), allows you to approach the question, genome-wide.\nIt works by extracting chromatin (DNA bound to protein), fragmenting it, and selecting the protein or protein variant of interest from this complex mixture with an antibody in some way specific for it. The subset of genome you will have isolated will constitute the sequences you expect your variant to bind, informing your inferences regarding its function.\n\nChIP-seq use in mapping histone modifications has been seminal in epigenetics research! (Ku et al., 2011)\n\nHere you can see a recap of the major steps:\n+ Cross-linking: add Formaldehyde\n+ Cell lysis (breakdown of cell membranes)\n+ Fragmentation of DNA fragments (shearing), e.g. digestion with specific endonuclease enzymes (dpn1) or sonication\n+ Addition of specific bead-coupled antibody against the protein of interest, separating it from the mixture\n+ Separate DNA from the protein (reverse cross-linking), and DNA purification\n+ DNA fragment amplification, library construction\n+ Library sequencing by NGS (essentially Illumina)"
  },
  {
    "objectID": "ChIP-seq_analysis/pages/ChIP-seq_principles.html#tips-for-designing-a-chip-seq-experiment",
    "href": "ChIP-seq_analysis/pages/ChIP-seq_principles.html#tips-for-designing-a-chip-seq-experiment",
    "title": "ChIP-seq_workflow",
    "section": "Tips for designing a ChIP-seq experiment",
    "text": "Tips for designing a ChIP-seq experiment\nBesides characterizing binding patterns in general, a common goal in ChIP-seq experiments is to identify changes in protein binding patterns between conditions, an application known as differential binding.\nEffective analysis of ChIP-seq data requires sufficient coverage by sequence reads (sequencing depth). It mainly depends on the size of the genome, and the number and size of the binding sites of the protein.\n\nFor mammalian (or any species with a relatively large genome) transcription factors (TFs) and chromatin modifications such as enhancer-associated histone marks: 20 million reads are adequate\nProteins with more binding sites (e.g., RNA Pol II) or more promiscuous factors (e.g. CTCF) need more reads, up to 60 million for mammalian ChIP-seq\nSequencing depth rules of thumb: &gt;10M reads for narrow peaks, &gt;20M for broad peaks (you will understand better this concept later in the Peak Calling section)\n\nAnother consideration is about sequence modality: long & paired-end reads are useful, but not essential - they may however help in specific, high-precision binding site discovery. Most of the times, ChIP-seq can be performed in single-end mode.\nAbout the number of technical replicates, unlike with RNA-Seq, more than two replicates do not significantly increase the number of identified peaks.\n\nChIP controls\nA successful ChIP-seq experiment must have the appropriate controls to optimize signal-noise ratio. Well-made controls help eliminate false positives. In fact, there is always some signal on open chromatin. This may be due to multiple factors, but can be boiled down to three reasons: A) non-specific binding from the antibody can precipitate random sequences B) digestion, sonication, or any other method of shearing will introduce biases towards certain sequences C) different operators will perform the same protocol slightly differently, yielding higher or lower signal/noise ratios.\nThe following controls are often used to abate these biases:\n\nAn “input” DNA sample in which a library is generated from DNA that has been cross-linked and sonicated but not immuno-precipitated. It controls for the bias introduced before even immunoprecipitating, i.e. from sonication.\nAn IgG “mock”-ChIP, using an antibody that will not bind to nuclear proteins and should generate random immuno-precipitated DNA. It controls for non-specific sequences that precipitate alongside the target protein, but are not bound by it.\nA Spike-In can also be introduced, using different genomes (e.g. Drosophila in a Human experiment) to control for handling variability between users, or batch differences between reagents. This helps dampen these confounders.\n\n\nInput DNA control is ideal in most of the cases. Indeed, one problem with IgG control is that if too little DNA is recovered after immuno-precipitation, sequencing library will be of low complexity and binding sites identified using this control could be biased. Read this biostars post for discussion."
  },
  {
    "objectID": "ChIP-seq_analysis/pages/ChIP-seq_principles.html#next-generation-sequencing",
    "href": "ChIP-seq_analysis/pages/ChIP-seq_principles.html#next-generation-sequencing",
    "title": "ChIP-seq_workflow",
    "section": "Next Generation Sequencing",
    "text": "Next Generation Sequencing\nNGS technologies (Illumina/PacBio/Ultima/BGI) allow the processing of millions of synthesis reactions in parallel, resulting in high throughput, higher sensitivity, speed and reduced cost compared to first generation sequencing technologies (e.g., Sanger method).\n\nGiven the vast amounts of quantitative sequencing data generated, NGS-based methods rely on resource-intensive data processing pipelines to analyze data.\n\nIn addition to the sequence itself, and unlike Sanger sequencing, the high-throughput nature of NGS provides quantitative information (depth of coverage) due to the high level of sequence redundancy at a locus.\nThere are short-read and long-read NSG approaches. Short reads of NGS range in size from 75 to 300 bp depending on the application and sequencing chemistry. NGS is taken to mean second generation technologies, however 3G and 4G technologies have since evolved (enable longer read sequences in excess of 10 kilobases).\nAmong 2G NGS chemistries, Illumina sequencing by synthesis (SBS) is the most widely adopted worldwide, responsible for generating more than 90% of the world’s sequencing data."
  },
  {
    "objectID": "ChIP-seq_analysis/pages/ChIP-seq_principles.html#the-basics-of-chip-seq-data-processing",
    "href": "ChIP-seq_analysis/pages/ChIP-seq_principles.html#the-basics-of-chip-seq-data-processing",
    "title": "ChIP-seq_workflow",
    "section": "The basics of ChIP-seq data processing",
    "text": "The basics of ChIP-seq data processing\n\nRaw Sequencing Output\nThe raw output of any sequencing run consists of a series of sequences (called tags or reads). These sequences can have varying length based on the run parameters set on the sequencing platform. Nevertheless, they are made available for humans to read under a standardized file format known as FASTQ. This is the universally accepted format used to encode sequences after sequencing. An example of real FASTQ file with only two reads is provided below.\n\n@Seq1\nAGTCAGTTAAGCTGGTCCGTAGCTCTGAGGCTGACGAGTCGAGCTCGTACG\n+\nBBBEGGGGEGGGFGFGGEFGFGFGGFGGGGGGFGFGFGGGFGFGFGFGFG\n@Seq2\nTGCTAAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGC\n+\nEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE\n\nFASTQ files are an intermediate file in the analysis and are used to assess quality metrics for any given sequence. The quality of each base call is encoded in the line after the + following the standard Phred score system.\n\n💡 Since we now have an initial metric for each sequence, it is mandatory to conduct some standard quality control evaluation of our sequences to eventually spot technical defects in the sequencing run early on in the analysis.\n\n\n\nQuality metrics inspection\nComputational tools like FastQC aid with the visual inspection of per-sample quality metrics from NGS experiments. Some of the QC metrics of interest to consider include the ones listed below, on the left are optimal metric profiles while on the right are sub-optimal ones:\nPer-base Sequence Quality: This uses box plots to highlight the per-base quality along all reads in the sequencing experiment, we can notice a physiological drop in quality towards the end part of the read.\nPer-sequence Quality Scores: Here we are plotting the distribution of Phred scores across all identified sequences, we can see that the high quality experiment (left) has a peak at higher Phred scores values (34-38).\nPer-base Sequence Content: Here we check the sequence (read) base content, in a normal scenario we do not expect any dramatic variation across the full length of the read since we should see a quasi-balanced distribution of bases.\nPer-sequence GC Content: GC-content refers to the degree at which guanosine and cytosine are present within a sequence, in NGS experiments which also include PCR amplification this aspect is crucial to check since GC-poor sequences may be enriched due to their easier amplification bias. In a normal random library we would expect this to have a bell-shaped distribution such as the one on the left.\nSequence Duplication Levels: This plot shows the degree of sequence duplication levels. In a normal library (left) we expect to have low levels of duplication which can be a positive indicator of high sequencing coverage.\nAdapter Content: In NGS experiments we use adapters to create a library. Sometimes these can get sequenced accidentally and end up being part of a read. This phenomenon can be spotted here and corrected using a computational approach called adapter trimming.\n\n\nTrimming\nThe read trimming step consists of removing a variable portion of read extremities that contain adapters/have suboptimal quality indicated by the Phred score. Tools like Cutadapt can be used to perform this task after read QC, and FASTQC can be eventually run just after read trimming to double-check positive effect of getting rid of bad sequences. Note that after this step, reads might have different lengths.\n\n\nRead alignment\nNow that we have assessed the quality of the sequencing data, we are ready to align the reads to the reference genome in order to map the exact chromosomal location they derive from.\n\nA reference genome is a set of nucleic acid sequences assembled as a representative example of a species’ genetic material. It does not accurately represent the set of genes of any single organism, but a mosaic of different nucleic acid sequences from each individual. For each model organism, several possible reference genomes may be available (e.g. hg19 and hg38 for human).\nAs the cost of DNA sequencing falls, and new full genome sequencing technologies emerge, more genome sequences continue to be generated. New alignments are built and the reference genomes improved (fewer gaps, fixed misrepresentations in the sequence, etc). The different reference genomes correspond to the different released versions (called “builds”).\n\nA mapper tool takes as input a reference genome and a set of reads. Its aim is to match each read sequence with the reference genome sequence, allowing mismatches, indels and clipping of some short fragments on the two ends of the reads.\n\nIllustration of the mapping process\n\n\nAmong the different mappers, Bowtie2 is a fast and open-source aligner particularly good at aligning sequencing reads of about 50 up to 1,000s of bases to relatively long genomes.\nBowtie2 can identify reads that are:\n\nuniquely mapped: read pairs aligned exactly 1 time\nmulti-mapped: reads pairs aligned more than 1 time\nunmapped: read pairs non concordantly aligned or not aligned at all\n\n\nMulti-mapped reads can happen because of repetition in the reference genome (e.g. multiple copies of a gene), particularly when reads are small. It is difficult to decide where these sequences come from and therefore most of the pipelines ignore them.\n\n\nMapping statistics\nChecking the mapping statistics is an important step to perform before to continue any analyses. There are several potential sources for errors in mapping, including (but not limited to):\n\nPCR artifacts: PCR errors will show as mismatches in the alignment\nsequencing errors\nerror of the mapping algorithm due to repetitive regions or other low-complexity regions.\n\nA low percentage of uniquely mapped reads is often due to (i) either excessive amplification in the PCR step, (ii) inadequate read length, or (iii) problems with the sequencing platform.\n\n70% or higher is considered a good percentage of uniquely mapped reads over all the reads, whereas 50% or lower is concerning. The percentages are not consistent across different organisms, thus the rule can be flexible!\n\nBut where the read mappings are stored?\n\n\nThe BAM file format\nA BAM (Binary Alignment Map) file is a compressed binary file storing the read sequences, whether they have been aligned to a reference sequence (e.g., a chromosome), and if so, the position on the reference sequence at which they have been aligned.\nA BAM file (or a SAM file, the non-compressed version) consists of:\n\nA header section (the lines starting with @) containing metadata, particularly the chromosome names and lengths (lines starting with the @SQ symbol)\nAn alignment section consisting of a table with 11 mandatory fields, as well as a variable number of optional fields.\n\n\nBAM file format \n\nQuestions:\n\n\nWhich information do you find in a BAM file that you also find in the FASTQ file?\n# Sequences and quality information\n\n\n\n\nWhat is the additional information compared to the FASTQ file?\n# Mapping information, Location of the read on the chromosome, Mapping quality, etc\n\n\n\n\n\nPeak calling\nThe read count data generated by ChIP-seq is massive. In order to predict the actual sites where the protein of interest is likely to bind, different peak calling methods have been developed. Peaks are regions with significant number of mapped reads that produce a pileup.\n\nChIP-seq is most often performed with single-end reads, and ChIP fragments are sequenced from their 5’ ends only. This creates two distinct peaks of read density! One on each strand with the binding site falling in the middle of these peaks. The distance from the middle of the peaks to the binding site is often referred to as the “shift”.\n\n\n\nForward (blue) and reverse (maroon) Read Density Profiles derived from the read data contribute to the Combined Density Profile (orange). Nat. Methods,2008\n\nThe most popular tool to find peaks is MACS2 which empirically models the shift size of ChIP-Seq reads, and uses it to improve the spatial resolution of predicted binding sites. Briefly, these are the steps performed by MACS:\n\nremoving duplicate reads\nmodelling the shift size\nscaling the libraries with respect to their controls\nperforming peak detection\nestimating False Discovery Rate (FDR)\n\nThe peak detection identifies areas in the genome that have been enriched with mapped reads.\n\nEnrichment = Immunoprecipitation reads/background reads (mock IP or untagged IP).\nIf an experimental control data is NOT available, a random genomic background is assumed.\n\n\n\n\n\nOverview of the Peak Calling step\n\n\n\nFinally, peaks are filtered to reduce false positives and ranked according to relative strength or statistical significance.\n\nDifferent peak profiles\nAn important factor that influences the sequencing depth that is required for a ChIP–seq experiment is whether the protein (or chromatin modification) is a point-source factor, a broad-source factor or a mixed-source factor.\n\nPoint sources occur at specific locations in the genome. This class includes sequence-specific transcription factors as well as some highly localized chromatin marks, for example, those associated with enhancers and transcription start sites. They will generate more often narrow peaks.\nBroad sources are generally those that cover extended areas of the genome, such as many chromatin marks (for example, histone H3 lysine 9 trimethylation (H3K9me3) marks). They will give raise to broad peaks.\nMixed-source factors, such as RNA polymerase II, yield both types of peaks. As expected, broad-source and mixed-source factors require a greater number of reads than point-source factors. Peaks generated will have a mixed profile between narrow and broad.\n\n\n\n\n\n\nAdditional QC metrics\nAfter peak calling, it’s important to check some metrics that are indicative of the overall quality of the ChIP-seq experiment. Here are two of the most useful:\n\nFRiP score: reports the percentage of reads overlapping within called peak. Can be useful to understand how much the IP sample is “enriched”.\nStrand cross-correlation: high-quality ChIP-seq produces significant clustering of enriched reads at locations bound by the protein of interest, that present as a bimodal density profile on the forward and reverse strands (peaks). The cross-correlation metric calculates how many bases to shift the bimodal peaks in order to get the maximum correlation between the two read clusters, which corresponds to the predominant fragment length.\n\n\n\nBigWig and BED file formats\nMost high-throughput data can be viewed as a continuous score over the bases of the genome. In case of RNA-seq or ChIP-seq experiments, the data can be represented as read coverage values per genomic base position.\nThis sort of data can be stored as a generic text file or can have special formats such as Wig (stands for wiggle) from UCSC, or the bigWig format, which is an indexed binary format of the wig files.\n\nThe bigWig format is great for data that covers a large fraction of the genome with varying and continuous scores, because the file is much smaller than regular text files that have the same information and it can be queried more easily since it is indexed. Most of the ENCODE project data can be downloaded in bigWig format!\n\nIf we want to know instead the peak locations in the genome as chromosome coordinates with well defined start and end positions, we want to look at BED files, that are the main output of the peak calling step.\nA typical BED file is a text file format used to store genomic regions as coordinates. The data are presented in the form of columns separated by tabs. The first three required BED fields are: “chrom”, “chromStart”, and “chromEnd”. There are 9 additional optional BED fields. You cna find more details in the UCSC webpage here.\n\nWe will use this file type to inspect peak locations and for future downstream analyses!\n\n\n\n\nCollapse data into a single dataset\nImagine that you are performing these steps of read processing not just for one library, but for a collection of samples with different replicates and experimental conditions, and you subsequently want to make differential comparisons across conditions. To this aim, it’s necessary to collapse the single peak files obtained from each single library into a single consensus peakset.\nIn this step you can also add a filtering to exclude genomic intervals that are identified as peaks only in a minority of samples. DiffBind and BEDTools are two common programs that can handle this task.\n\n\nSource\n\nIt can be helpful to make a plot of how many peaks overlap in how many samples, like this one:\n\n\nThis plot shows that there are almost 4000 total merged peaks, representing the union of all intervals. At the other extreme, there are around 100 peaks that overlap in all 11 samples, representing the intersection of all the samples.\n\n\nWhich should we chose? Given the rigor of the statistical analysis that we are going to perform, now we can choose a more inclusive consensus set. The default is to make a consensus peakset using peaks identified in at least 2 samples.\n\n\n\nCounting reads in consensus peaks\nOnce consensus genomic regions are defined, the next step is to count the number of sequencing reads that align to these regions. This read counting process provides quantitative information about the strength and extent of protein binding within the identified peaks.\n\nUniquely mapped reads can be counted within peaks in the consensus using a tool called FeatureCounts.\n\nSample counts for all the consensus peaks are output as a tabular file, in which each row represents one peak, and you have one column for each sample. We will now load one and take a closer look: this will be our starting point in the hands-on analysis of a ChIP-seq dataset.\n\nBefore going on, let’s summarize the steps of a ChIP-seq analysis workflow that we have seen so far with the following scheme. You can find the file format names associated to the output of each task."
  },
  {
    "objectID": "ChIP-seq_analysis/pages/ChIP-seq_analysis_part1.html",
    "href": "ChIP-seq_analysis/pages/ChIP-seq_analysis_part1.html",
    "title": "ChIP-seq_analysis_part1",
    "section": "",
    "text": "Introduction to ChIP-seq\nDataset introduction and exploration\nData normalization with edgeR\nDiagnostic and exploratory analysis\nResources for ChIP-seq and other omics data"
  },
  {
    "objectID": "ChIP-seq_analysis/pages/ChIP-seq_analysis_part1.html#objectives",
    "href": "ChIP-seq_analysis/pages/ChIP-seq_analysis_part1.html#objectives",
    "title": "ChIP-seq_analysis_part1",
    "section": "",
    "text": "Introduction to ChIP-seq\nDataset introduction and exploration\nData normalization with edgeR\nDiagnostic and exploratory analysis\nResources for ChIP-seq and other omics data"
  },
  {
    "objectID": "ChIP-seq_analysis/pages/ChIP-seq_analysis_part1.html#install-the-packages",
    "href": "ChIP-seq_analysis/pages/ChIP-seq_analysis_part1.html#install-the-packages",
    "title": "ChIP-seq_analysis_part1",
    "section": "Install the packages",
    "text": "Install the packages\nThe analyses we are going to perform require specific functions that are not included in the basic set of functions in R. These functions are collected in specific packages. R packages are extensions to the R programming language that contain code, data and documentation which help us performing standardized workflows. In the chunk below, we instruct R to install the packages that we will need later on through the workshop.\n\nWe have already installed the necessary packages. However, if a library is not present copy the relevant command line and paste it to your R script.\n\n\n# # Install packages from Bioconductor\n# if (!require(\"BiocManager\", quietly = TRUE))\n#   install.packages(\"BiocManager\")\n# \n# # Install packages from CRAN\n# #install.packages(\"tidyr\")\n# #install.packages(\"dplyr\")\n# #install.packages(\"googledrive\")\n# \n# # For differential analysis\n# BiocManager::install(\"vsn\")\n# BiocManager::install(\"edgeR\")\n# install.packages(\"statmod\")\n# \n# # For visualizations\n# install.packages(\"hexbin\")\n# install.packages(\"pheatmap\")\n# #install.packages(\"RColorBrewer\")\n# #install.packages(\"ggrepel\")\n# #install.packages(\"circlize\")\n# \n# # For downstream analysis\n# install.packages(\"gprofiler2\")\n# \n# # Clean garbage\n# gc()\n\nDuring installation of packages, you will see many messages being displayed on your R console, you usually need to pay attention to them if they are red and specify an error!\nIf you encounter any of the messages below during installation, follow this procedure here:\n\n# R asks for package updates, answer \"n\" and type enter\n# Question displayed:\nUpdate all/some/none? [a/s/n]:\n\n# Answer to type:  \nn\n\n# R asks for installation from binary source, answer \"no\" and type enter\n# Question displayed:\nDo you want to install from sources the packages which need compilation? (Yes/no/cancel)\n\n# Answer to type:\nno"
  },
  {
    "objectID": "ChIP-seq_analysis/pages/ChIP-seq_analysis_part1.html#the-chip-seq-dataset",
    "href": "ChIP-seq_analysis/pages/ChIP-seq_analysis_part1.html#the-chip-seq-dataset",
    "title": "ChIP-seq_analysis_part1",
    "section": "The ChIP-seq dataset",
    "text": "The ChIP-seq dataset\nThe dataset we will analyze comes from this paper published from our lab in 2021:\n\nDella Chiara, Gervasoni, Fakiola, Godano et al., 2021 - Epigenomic landscape of human colorectal cancer unveils an aberrant core of pan-cancer enhancers orchestrated by YAP/TAZ\n\nIts main object was to explore the way cancer cells use enhancers as opposed to nonmalignant cells, and we did so by using ChIP-seq on histone marks extensively. We generated organoid lines to model colorectal tumors, analyzed their epigenome, and compared it to the ATAC-seq-derived chromatin activity data of multiple other malignancies. We found a small number of enhancer sequences were conserved across all these types, and identified a transcription factor that linked them - the YAP/TAZ pair - that when perturbed would cause the death of malignant, but not normal, organoids, therefore representing a potential pan-cancer therapeutic target.\n\n\n\n✅ In this workshop, we will re-analyze a portion of the ChIP-seq dataset used in the paper, pertaining to Histone 3 Lysine 27 Acetylation - a marker of activation present at active regulatory sequences, enhancers and promoters alike."
  },
  {
    "objectID": "ChIP-seq_analysis/pages/ChIP-seq_analysis_part1.html#load-and-explore-the-dataset",
    "href": "ChIP-seq_analysis/pages/ChIP-seq_analysis_part1.html#load-and-explore-the-dataset",
    "title": "ChIP-seq_analysis_part1",
    "section": "Load and explore the dataset",
    "text": "Load and explore the dataset\nIn order to speed up the computations and keep memory usage low, we have subset the dataset only to chromosome 12. It will be interesting to see if we can recapitulate similar analyses by looking only at a single chromosome 🤓.\nData are in this public Google Drive folder. You will find:\n\nraw_counts_chr12.matrix: the peak by sample matrix containing the number of reads detected for each peak in each sample.\ncolData.txt: a tabular file containing our metadata related to columns of the count table, which contains different info about our samples (e.g. the treatment, the sample origin, etc.).\npeakset.bed: a BED file with the chromosome locations of the entire consensus peakset (i.e. all chromosomes).\nrecurrence_chr12.matrix: this is a table where you can find if any of the intervals that constitute the consensus peakset is also called as peak in each separate sample. Remember that when a consensus peakset is created, usually genomic intervals called as peaks in at least 2 out of all the samples are kept in the consensus. Therefore, in the consensus you might find intervals that are called in 3 or in all the samples. It might be interesting to check how the peaks are distributed.\ndba_Korg_Ntissue_homer_annot.txt: this file contains information about the annotation of each consensus peakset to the nearest gene TSS. You will understand later its usage.\nKorg_UP_regions_results.txt and Ncr_UP_regions_results.txt: these files store the differential analysis results for the entire peakset and we will need them to perform downstream functional analyses.\n\nOpen the Google Drive link above in teh browser, check the presence of the files and download them on your computer. Create a new directory within C:\\Users\\student to store the data.\nCreate a new R notebook and save it in the same folder. Check the path to the current working directory and the list of files you have just downloaded. Modify the code below according to the directory where you downloaded the data.\n\ngetwd()\nlist.files(\"./\")\n\nImport the counts and metadata information for the samples.\n\ncounts &lt;- read.table(\"../MBMM25_uploadata/raw_counts_chr12.matrix\",text = ., sep=\"\\t\") %&gt;% as.data.frame()\n\nsamples &lt;- read.table(\"../MBMM25_uploadata/colData.txt\", text = ., sep=\"\\t\") %&gt;% as.data.frame()\n\nWe can now explore the data that we have just loaded in the current R session to familiarize with it.\n\n# Check out the counts\nhead(counts, 10)\n\n\n\n\n\n\n\nSQ_2157\nSQ_1990\nSQ_2010\nSQ_2163\nSQ_2204\nSQ_2212\nSQ_2216\nSQ_2222\nSQ_2288\nSQ_2303\nSQ_2298\nSQ_2145\nGSM2058021\nGSM2058022\nGSM2058023\n\n\n\n\nreg_6364\n8\n1\n1\n97\n1\n13\n3\n12\n24\n19\n47\n4\n85\n34\n185\n\n\nreg_6365\n26\n20\n27\n47\n58\n67\n47\n52\n65\n21\n43\n11\n79\n56\n216\n\n\nreg_6366\n1\n9\n1\n6\n1\n1\n1\n7\n1\n1\n45\n1\n65\n44\n169\n\n\nreg_6367\n1\n1\n1\n21\n2\n14\n4\n5\n2\n1\n52\n29\n132\n66\n188\n\n\nreg_6368\n1\n1\n15\n17\n6\n10\n6\n1\n11\n5\n11\n3\n11\n23\n56\n\n\nreg_6369\n184\n304\n215\n661\n278\n519\n466\n435\n500\n267\n1045\n297\n1950\n1562\n3860\n\n\nreg_6370\n28\n1\n2\n92\n15\n21\n19\n50\n49\n1\n57\n9\n91\n44\n136\n\n\nreg_6371\n141\n290\n281\n673\n196\n398\n438\n303\n451\n188\n666\n222\n1793\n1409\n3416\n\n\nreg_6372\n1\n1\n3\n26\n3\n1\n1\n1\n1\n1\n39\n1\n39\n25\n222\n\n\nreg_6373\n63\n86\n112\n293\n70\n168\n55\n99\n268\n135\n187\n31\n580\n229\n894\n\n\n\n\n\n\n\nWe can then check the shape of our counts table (i.e. how many different peaks we are detecting and how many different samples?)\n\n# How many rows and columns does our count table have?\ndim(counts)\n\n[1] 1581   15\n\n\nWe can see that our table contains count information for 1581 peaks and 15 samples.\nWe can also inspect the metadata from the samples which is stored in the samples object we created above.\n\n# What does the table look like?\nsamples\n\n\n\n\n\n\n\ngroups\nsizeFactor\nTissue\nSampleID\nTreatment\n\n\n\n\nSQ_2157\nK_org\n2.489936\n4KE\nSQ_2157\nK_org\n\n\nSQ_1990\nK_org\n2.758060\n8KE\nSQ_1990\nK_org\n\n\nSQ_2010\nK_org\n2.760352\n10KE\nSQ_2010\nK_org\n\n\nSQ_2163\nK_org\n2.425892\n13KE\nSQ_2163\nK_org\n\n\nSQ_2204\nK_org\n1.863534\n18KE\nSQ_2204\nK_org\n\n\nSQ_2212\nK_org\n2.580778\n11KW\nSQ_2212\nK_org\n\n\nSQ_2216\nK_org\n2.159358\n24KE\nSQ_2216\nK_org\n\n\nSQ_2222\nK_org\n2.203927\n22KE\nSQ_2222\nK_org\n\n\nSQ_2288\nK_org\n2.402964\n36KE\nSQ_2288\nK_org\n\n\nSQ_2303\nK_org\n2.430445\n41KE\nSQ_2303\nK_org\n\n\nSQ_2298\nN_crypts\n3.756529\nCR_41_mp\nSQ_2298\nN_crypts\n\n\nSQ_2145\nN_crypts\n2.804850\nCR_28_mp\nSQ_2145\nN_crypts\n\n\nGSM2058021\nN_crypts\n1.252530\nCR_28\nGSM2058021\nN_crypts\n\n\nGSM2058022\nN_crypts\n1.000000\nCR_29\nGSM2058022\nN_crypts\n\n\nGSM2058023\nN_crypts\n2.476903\nCR_37\nGSM2058023\nN_crypts\n\n\n\n\n\n\n\n\n# What is the shape of this samples table?\ndim(samples)\n\n[1] 15  5\n\n\nIn this case, this samples table has as many rows (15) as there are samples (which in turn is equal to the number of columns in the counts table), with columns containing different types of information related to each of the sample in the analysis.\nWe can verify that the samples in the counts table matches the samples in the metadata table.\n\ntable(colnames(counts)==rownames(samples))\n\n\nTRUE \n  15 \n\n# What if we reverse the order of the samples? \ntable(colnames(counts)==rev(rownames(samples)))\n\n\nFALSE  TRUE \n   14     1 \n\n#colnames(counts)==rev(rownames(samples))"
  },
  {
    "objectID": "ChIP-seq_analysis/pages/ChIP-seq_analysis_part1.html#savingloading-files",
    "href": "ChIP-seq_analysis/pages/ChIP-seq_analysis_part1.html#savingloading-files",
    "title": "ChIP-seq_analysis_part1",
    "section": "Saving/Loading Files",
    "text": "Saving/Loading Files\nLet’s save this object with samples information in a file format where columns are separated by commas. You might be familiar with this format if you have worked quite a bit in Excel. In R, we can save tabular data with the write.table() function specifying the location (the file name) we want. This is useful in the case our R session dies or we decide to interrupt it. In this case we will not have to run the whole analysis from the beginning and we can just source the file and load it!\n\nwrite.table(samples, \"../results/samples_table.csv\", sep = \",\", quote = FALSE)\n\nWe can load the object back into the current session by using the following code line:\n\nsamples &lt;- read.table(\"../results/samples_table.csv\", sep = \",\")\n\nSave also the counts\n\n# Load the data again\ncounts &lt;- read.csv(\"../results/counts_table.csv\")\nsamples &lt;- read.csv(\"../results/samples_table.csv\")\n\n! Troubleshoot\n\nWhere are you? Where is the file located? Check the current directory and navigate through the folders with getwd() and dir()"
  },
  {
    "objectID": "ChIP-seq_analysis/pages/ChIP-seq_analysis_part1.html#brief-recap-of-the-dataset",
    "href": "ChIP-seq_analysis/pages/ChIP-seq_analysis_part1.html#brief-recap-of-the-dataset",
    "title": "ChIP-seq_analysis_part1",
    "section": "Brief recap of the dataset",
    "text": "Brief recap of the dataset\nFirst of all, let’s make a recap on the dataset that we are going to analyze.\nEach row of the counts table corresponds to a genomic interval within chromosome 12. We discussed about a standard analysis that requires a peak caller (such as MACS) used on the aligned reads to call peaks. While having called peaks for the sample is useful in a variety of ways, it is possible to perform a quantitative analysis without using called peaks. For example, in some cases, the regions of interest may be known in advance (such as a list of known gene promoters).\nThis is actually our case, because the genomic regions that we’ll analyze are the active enhancers defined by ChromHMM. Using this machine-learning approach, we have characterized the chromatin states in CRC organoids and normal colon tissues, by combining multiple histone mark ChIP-seq profiles including H3K27 acetylation. Among the different chromatin states, we were able to identify genomic regions with active enhancer features. We have then generated a consensus peakset by merging peaks called in at least two samples.\n\n\n\nOn these consensus peakset, we then counted reads from ChIP-seq on H3K27Ac for each sample. NB: This is a compute-intensive step that might have taken too long to run in the workshop! Thus we have already perfomed this step and the table represents the counts for each consensus region on chr12 across samples."
  },
  {
    "objectID": "ChIP-seq_analysis/pages/ChIP-seq_analysis_part1.html#data-normalization-removing-uninteresting-differences",
    "href": "ChIP-seq_analysis/pages/ChIP-seq_analysis_part1.html#data-normalization-removing-uninteresting-differences",
    "title": "ChIP-seq_analysis_part1",
    "section": "Data Normalization: removing uninteresting differences",
    "text": "Data Normalization: removing uninteresting differences\nSince we want to highlight interesting biological differences between groups of samples in our dataset, the first thing to do is to ensure that we take into account and minimize all of the uninteresting differences between samples. This is accomplished by normalizing the data, a mandatory step before any differential analysis, if we want to make counts comparable both across samples and across different peaks, without any unwanted bias.\nThe main differences in the dataset that we want to normalize for are:\n\nthe Sequencing Depth (expressed as the total amount of uniquely mapped reads in a sample): even between samples that were sequenced in the same sequencing run as part of the same experiments (but even more likely if samples have been generated in multiple batches), differences in the sequencing depth are expected. It’s important to take this into account because differences in sequencing depth can erroneously lead to the perception of genomic intervals having differential signals.\n\n\n\n\n\nGenomic interval length: this is a potential bias if we want to compare across group of intervals other than across samples. Indeed, the larger the genomic region, the higher the amount of reads that will be counted on it, and viceversa.\n\n\n\n\nDuring the years, many approaches to data normalization have been attempted. In the table below, we summarized three common methods that can be employed to account for differences in library size (i.e. the sequencing depth) and the genomic interval length.\n\n\n\n\n\n\n\n\nNormalization Method\nAccounted Factors\nDescription\n\n\n\n\nCPM (counts per million)\nSequencing depth\nCounts scaled by total read number\n\n\nTPM (transcripts per million)\nSequencing depth and gene length\nCounts per length of transcript (kb) per million mapped reads\n\n\nFPKM/RPKM\nSequencing depth and gene length\nCounts per kilobase of exon mapped reads per million mapped reads\n\n\n\n\nNotice the term “transcript” for TPM or “exon” in the method descriptions. Historically, these methods have been developed for RNA-seq data, dealing with gene expression counts, but they can be extended for other sequencing technologies. See also the Normalization Discussion section.\n\nCPM, TPM and FPKM/RPKM are considered simple normalization methods, that can be useful to scale NGS data. However, newer and more sophisticated approaches have been developed to take into account technical variability and sample-specific biases. Two of these are the DESeq2’s median of ratios and the edgeR’s trimmed mean of M values. These are indeed more advanced statistical methods used for normalization and differential analysis in multiple sequencing data, including RNA-seq and ATAC-seq.\n\n\n\nNormalization Method\nAccounted Factors\nDescription\n\n\n\n\nDESeq2’s median of ratios1\nSequencing depth and RNA composition\nCounts are divided by a sample-specific size factor\n\n\nedgeR’s trimmed mean of M values2\nSequencing depth, RNA composition and gene length\nWeighted trimmed mean of the log ratio of expression between samples\n\n\n\nAs you can see from the table, with respect to the other methods, these ones can correct for one additional unwanted difference across libraries: the Composition Bias. As the name suggests, composition biases are formed when there are differences in the composition of sequences across libraries. Highly enriched regions consume more sequencing resources and thereby suppress the representation of other regions. Scaling by library size fails to correct for this as composition biases can still occur in libraries of the same size.\n\n\n\nOut of all these, we will use one of the more advanced ones provided in the edgeR package which will be now introduced."
  },
  {
    "objectID": "ChIP-seq_analysis/pages/ChIP-seq_analysis_part1.html#about-the-edger-package",
    "href": "ChIP-seq_analysis/pages/ChIP-seq_analysis_part1.html#about-the-edger-package",
    "title": "ChIP-seq_analysis_part1",
    "section": "About the edgeR Package",
    "text": "About the edgeR Package\n\nIntroduction\nOne of the aims of this workshop is to understand which genomic regions have a differential signal for H3K27Ac in our dataset, that is, have a difference in enhancer activty. In particular, we want to identify regions that are gaining more of this histone modification in CRC organoid samples, that might be enhancer regions with increased activity compared to normal organoids. To do so, we will compare H3K27Ac levels across samples and statistically assess and quantify differences arising between the conditions represented by our categories of samples (i.e., normal colon crypts and CRC organoids). EdgeR is a widely used package for normalization and differential analysis on bulk sequencing data.\n\nDetailed explanations of the statistical procedures implemented in the package are available in the package’s vignette.\n\nWe will start by loading the packages.\n\n# Load the package\nlibrary(edgeR)\n\nYou can have a look at all the functions contained in the edgeR package by typing the following command:\n\n# This should open a popup window in the lower right part of the screen displaying the functions in the package\n??edgeR"
  },
  {
    "objectID": "ChIP-seq_analysis/pages/ChIP-seq_analysis_part1.html#create-a-dgelist-object-with-counts-sample-metadata-and-design-formula",
    "href": "ChIP-seq_analysis/pages/ChIP-seq_analysis_part1.html#create-a-dgelist-object-with-counts-sample-metadata-and-design-formula",
    "title": "ChIP-seq_analysis_part1",
    "section": "Create a DGEList object with counts, sample metadata and design formula",
    "text": "Create a DGEList object with counts, sample metadata and design formula\nIn order for the package to read and understand our data and correctly perform the analysis, we need to organize our data in a way that the functions of the package can handle. This new object that we are going to create is called DGEList and there is a utility function to create one starting from the ingredients we currently have, (1) a table of counts (our counts object), (2) a table with sample information (our samples object) and (3) what comparisons we want to perform, this is called a design formula.\n\nBehind The Design Formula\nThe design formula should contain the name of a column of interest in our table of samples (that we can call factor) which stores the information related to the levels (or categories) we want to contrast. Let’s say that we have a dataset with two conditions (condition_1 vs condition_2) that we want to compare. The samples table will look like this, with three replicates for each of the two conditions:\n\n\n\nSample Code\nPatient\nCondition\n\n\n\n\nSA1\nPt1\nCondition_1\n\n\nSA2\nPt2\nCondition_1\n\n\nSA3\nPt3\nCondition_1\n\n\nSA4\nPt1\nCondition_2\n\n\nSA5\nPt2\nCondition_2\n\n\nSA6\nPt3\nCondition_2\n\n\n\n\nPaired Analyses\nThe optimal setting for the analysis (decided experimentally) is to have paired samples. This might be a somewhat difficult concept to grasp, but for our table above this means that every Patient contributes equally to the two categories in the Condition columns that we are interested in. In this setting, we are fully capable of exploiting the statistics behind the tools we use for differential analysis by correcting for the uninteresting differences arising between patients. This aspect greatly helps the analysis and improves the statistical validity of the results.\nRemember, this is something achieved by deciding the experimental setting beforehand! Ideally this should be done through a collaborative effort between bioinformaticians/statisticians and bench scientists!\nIf we are interested in performing a differential expression analysis comparing condition_1 versus condition_2, then our design formula should specify the Condition factor.\n\n💡 What is the column that we are interested in when specifying the design formula using in our samples table?\n\n\n💡 What is the factor and levels in our case?\n\nNow that we also understand the design formula, we can create the DGEList object with the data that we loaded beforehand, but first we need to check that the columns of the counts table are in the same order of the rows of the sample table, this is important since we want to be sure that the right levels of expression are associated to the right sample.\n\nall(rownames(samples) == colnames(counts))\n\n[1] TRUE\n\n\nFurther, we will get rid of non-useful columns in our sample metadata:\n\nsamples &lt;- dplyr::select(samples, -c(sizeFactor, Treatment))\n\nAnd now we can build the object:\n\n# Create a design formula. Notice that we are creating an object type known as \"factor\"\nsample_group &lt;- factor(samples$groups, levels=c(\"N_crypts\", \"K_org\"))\n\ndesign &lt;- model.matrix(~ sample_group)\n\n# Create a `DGEList` object and call it dds\ndds &lt;- DGEList(counts = counts, samples = samples)\n\n# Let's save the `design` in the dds object\ndds$design &lt;- design\n\nRemember that dds is just a list in R which can be updated with different elements.\nWe can remove the counts table from our R environment since that information is stored in our DGEList object now. This is useful to save on memory space!\n\n# Remove original `counts` table to save memory space\nrm(counts)\ngc()\n\nGreat! You have created a DGEList object which we called dds, this contains all the information related to the counts table and the sample information table in one spot. We can have a look at the sample information table and the counts table in the dds object like so:\n\n# Look at the table with sample information\nhead(dds$samples)\n\n\n\n\n\n\n\ngroup\nlib.size\nnorm.factors\ngroups\nTissue\nSampleID\n\n\n\n\nSQ_2157\nK_org\n69284\n1\nK_org\n4KE\nSQ_2157\n\n\nSQ_1990\nK_org\n96388\n1\nK_org\n8KE\nSQ_1990\n\n\nSQ_2010\nK_org\n112029\n1\nK_org\n10KE\nSQ_2010\n\n\nSQ_2163\nK_org\n169859\n1\nK_org\n13KE\nSQ_2163\n\n\nSQ_2204\nK_org\n108070\n1\nK_org\n18KE\nSQ_2204\n\n\nSQ_2212\nK_org\n162626\n1\nK_org\n11KW\nSQ_2212\n\n\n\n\n\n\n\nWe can see that some new columns were added to the samples table present in our DGEList object when we created it (the group, lib.size, norm.factors columns)! These will be used by edgeR later on for data normalization!\n\nCan you compute the library sizes yourself and compare them to the ones generated by edgeR?\n\nWe can also take a look at the table containing the counts, which is just another element of our DGEList object:\n\n# Look at the table with count information\nhead(dds$counts)\n\n\n\n\n\n\n\nSQ_2157\nSQ_1990\nSQ_2010\nSQ_2163\nSQ_2204\nSQ_2212\nSQ_2216\nSQ_2222\nSQ_2288\nSQ_2303\nSQ_2298\nSQ_2145\nGSM2058021\nGSM2058022\nGSM2058023\n\n\n\n\nreg_6364\n8\n1\n1\n97\n1\n13\n3\n12\n24\n19\n47\n4\n85\n34\n185\n\n\nreg_6365\n26\n20\n27\n47\n58\n67\n47\n52\n65\n21\n43\n11\n79\n56\n216\n\n\nreg_6366\n1\n9\n1\n6\n1\n1\n1\n7\n1\n1\n45\n1\n65\n44\n169\n\n\nreg_6367\n1\n1\n1\n21\n2\n14\n4\n5\n2\n1\n52\n29\n132\n66\n188\n\n\nreg_6368\n1\n1\n15\n17\n6\n10\n6\n1\n11\n5\n11\n3\n11\n23\n56\n\n\nreg_6369\n184\n304\n215\n661\n278\n519\n466\n435\n500\n267\n1045\n297\n1950\n1562\n3860\n\n\n\n\n\n\n\n\n💡 In R, list elements are accessible with the $ accessor. Our dds object is indeed a list made up of three elements, the counts table, the samples table and the design table, these are accessible using $ like we did above."
  },
  {
    "objectID": "ChIP-seq_analysis/pages/ChIP-seq_analysis_part1.html#filtering-data",
    "href": "ChIP-seq_analysis/pages/ChIP-seq_analysis_part1.html#filtering-data",
    "title": "ChIP-seq_analysis_part1",
    "section": "Filtering Data",
    "text": "Filtering Data\nGenes with very low counts across all libraries provide little evidence for differential expression. In addition, the pronounced discreteness of these counts interferes with some of the statistical approximations that are used later in the pipeline. These genes should be filtered out prior to further analysis. Users can have their own definition of expression but in general counts are dropped if they are not expressed in a minimum number of samples based on the minimum group size or if it does not achieve a minimum number of counts across all samples.\nedgeR provides the filterByExpr() function that retains genes with sufficiently large counts for statistical analysis.\n\n# Dimensions of the object before filtering\ndim(dds)\n\n[1] 1581   15\n\n\n\n# Perform filtering, subset the dds object and check the dimensions\nkeep &lt;- filterByExpr(dds, group=dds$samples$group)\ndds &lt;- dds[keep, , keep.lib.sizes=FALSE]\ndim(dds)\n\n[1] 1490   15\n\n\n\n# How many regions were filterd out?\ncounts[!keep,] %&gt;% dim()\n\n[1] 91 15\n\n\nWe can verify that the count distribution of the filtered regions is lower compared to those that were kept.\n\nlibrary(tidyr)\nlibrary(ggplot2)\n\n# Density plot for filtered regions\ncounts[!keep,] %&gt;% \n        mutate(Region=rownames(.)) %&gt;%  \n        gather(., samples, value, -Region) %&gt;% \n        #head()\n        ggplot(., aes(log2(value), fill=samples)) + geom_density() + theme_light()\n\n\n\n\n\n\n\n\n\nCheck the count distribution of the retained regions\n\n\n\n\n\n\n\n\n\n\nIt is more helpful to compare them on the same plot.\n\ncounts %&gt;% \n        mutate(Region=rownames(.),\n               Keep=keep) %&gt;%  \n        gather(., value, variable, -c(Region,Keep)) %&gt;% \n        #head()\n        ggplot(., aes(log2(variable), fill=Keep)) + geom_density() + theme_light()\n\n\n\n\n\n\n\n\n\nTry to create a boxplot instead of a histogram."
  },
  {
    "objectID": "ChIP-seq_analysis/pages/ChIP-seq_analysis_part1.html#normalizing-count-data",
    "href": "ChIP-seq_analysis/pages/ChIP-seq_analysis_part1.html#normalizing-count-data",
    "title": "ChIP-seq_analysis_part1",
    "section": "Normalizing Count Data",
    "text": "Normalizing Count Data\nAs we have discussed above, normalization is an integral step to the downstream analysis and necessary for differential comparison. In this section we will normalize our data using the calcNormFactors function of the package. As we have previously introduced, edgeR uses the trimmed mean of M-values (TMM) method to calculate a set of size factors to minimize the log-fold change differences occurring between samples (uninteresting) for the majority of genomic intervals. The counts for each sample get then multiplied by the scaling factors to generate what is referred to as effective library size, which will be used for all downstream analyses.\n\n# Call the function to normalize count data\ndds &lt;- calcNormFactors(dds)\n\nWe can check the values of the computed size factors by doing the following, note how there are as many size factors as there are samples and they are inserted in a column of the samples table named norm.factors in our DGEList object:\n\ndds$samples\n\n\n\n\n\n\n\ngroup\nlib.size\nnorm.factors\ngroups\nTissue\nSampleID\n\n\n\n\nSQ_2157\nK_org\n68628\n0.7617531\nK_org\n4KE\nSQ_2157\n\n\nSQ_1990\nK_org\n95645\n0.9517516\nK_org\n8KE\nSQ_1990\n\n\nSQ_2010\nK_org\n111383\n1.0635417\nK_org\n10KE\nSQ_2010\n\n\nSQ_2163\nK_org\n168819\n1.0359859\nK_org\n13KE\nSQ_2163\n\n\nSQ_2204\nK_org\n107640\n0.9422863\nK_org\n18KE\nSQ_2204\n\n\nSQ_2212\nK_org\n161795\n0.8542493\nK_org\n11KW\nSQ_2212\n\n\nSQ_2216\nK_org\n166417\n0.8582417\nK_org\n24KE\nSQ_2216\n\n\nSQ_2222\nK_org\n125528\n1.0216942\nK_org\n22KE\nSQ_2222\n\n\nSQ_2288\nK_org\n192107\n1.1007166\nK_org\n36KE\nSQ_2288\n\n\nSQ_2303\nK_org\n91710\n0.8959298\nK_org\n41KE\nSQ_2303\n\n\nSQ_2298\nN_crypts\n105375\n1.3540033\nN_crypts\nCR_41_mp\nSQ_2298\n\n\nSQ_2145\nN_crypts\n31148\n1.2742282\nN_crypts\nCR_28_mp\nSQ_2145\n\n\nGSM2058021\nN_crypts\n175916\n1.0590448\nN_crypts\nCR_28\nGSM2058021\n\n\nGSM2058022\nN_crypts\n119435\n0.9694495\nN_crypts\nCR_29\nGSM2058022\n\n\nGSM2058023\nN_crypts\n285704\n1.0153128\nN_crypts\nCR_37\nGSM2058023\n\n\n\n\n\n\n\n\n💡 NOTE: Although edgeR does not use normalized counts as input for the differential analysis (the normalization process happens inside automatically), the normalized counts we just generated are useful when plotting results and performing clustering.\n\n\nNormalization discussion\nNormalization of experimental data is particularly important in ChIP-seq (and ATAC-seq) analysis, and may require more careful consideration than needed for RNA-seq analysis. This is because the range of ChIP-seq experiments covers more cases than RNA-seq, which usually involve a similar set of possible expressed genes and/or transcripts, many of which are not expected to significantly change expression. ChIP, ATAC, and similar enrichment-based sequencing data may not follow the assumptions inherent in popular methods for normalizing RNA-seq data, as well as exhibiting different types of efficiency and other biases.\n\nReference reads\nThe reads used as the basis for scaling or normalizing the data. These can be total reads per sample, a subset of reads, or even a reference distribution derived from all samples.\nWhile in RNA-seq experiments the expression matrix is normalized based on the reads that uniquely overlap genes or transcripts, this does not necessarily apply to a count matrix based on a consensus peakset.\nThe DiffBind package  is a tool that has been designed specifically for ChIP-seq data analysis. Using this tools, you can normalize your data using two different sets of reference reads:\n\none uses all the reads (the full library size)\nthe other normalizes bases only on the total number of reads in the consensus peakset (namely, the effective library size).\n\nThe major difference is that the full library size takes into account also “background” reads, that are most of the reads in a ChIP-seq sample library! In brief, the reads that are used as the reference for normalizing can be as important as the normalization method itself (e.g. background vs. enriched consensus reads ). The fact that we consider the background might reflect in a less biased normalization calculation.\nTake home message: &gt; In this workshop, to make things less complex, we used a “common” normalization method without any prior in-depth analysis on the best strategy to normalize these specific data in this context. But just keep in mind that some normalization methods might be more “correct” than others in some circumstances."
  },
  {
    "objectID": "ChIP-seq_analysis/pages/ChIP-seq_analysis_part1.html#transforming-count-data-for-visualization-purposes",
    "href": "ChIP-seq_analysis/pages/ChIP-seq_analysis_part1.html#transforming-count-data-for-visualization-purposes",
    "title": "ChIP-seq_analysis_part1",
    "section": "Transforming Count Data for visualization purposes",
    "text": "Transforming Count Data for visualization purposes\nAfter we have normalized our data, we need to perform a transformation. There are many ways to transform count data but all of them achieve the goal of removing the dependence of the variance on the mean counts across samples (something called homoscedasticity) in order to highlight interesting and biologically relevant expression trends even for genes expressed at lower values. This is because many downstream analyses (like PCA, clustering, distance calculation) assume homoscedasticity — equal variance across features. If we do not stabilize for the mean-variance relationship, these analyses will be dominated by highly expressed genes — even if those genes might not be biologically interesting. Low and moderately expressed genes (which might carry the biological signal) are ignored, because they contribute much less to the variance or distances.\nWe transform the data using a function provided in the edgeR package called cpm() which also performs a logarithmic transformation which has the effect of reshaping the data to achieve gene-wise distributions which resemble a normal distribution. Without getting too much into the details of the workings of the function, we will transform the data and then look at how the gene-wise relationship between the mean and variance in our normalized data changes before and after the transformation. The purpose of this procedure is to allow proper data visualization later in the analysis, the transformed data is NOT used for the differential expression analysis which instead starts from raw counts!\nThe following code is used to plot the mean/standard deviation relationship of every gene before the transformation.\n\nlibrary(vsn)\n\n# Plot before data transformation\nmeanSdPlot(dds$counts)\n\n\n\n\n\n\n\n\nCheck the distribution of counts, the mean and sd for each region.\n\n# Quantiles of counts\ndds$counts %&gt;% quantile()\n\n  0%  25%  50%  75% 100% \n   1    9   30   83 7000 \n\n# Quantiles of standard deviation across regions\napply(dds$counts, 1, sd) %&gt;% quantile()\n\n         0%         25%         50%         75%        100% \n   6.023762   21.026570   37.602235   71.282102 1668.777091 \n\n# Quantiles of mean across regions\napply(dds$counts, 1, mean) %&gt;% quantile()\n\n         0%         25%         50%         75%        100% \n   6.533333   20.550000   38.200000   83.700000 2323.133333 \n\n\nTransform the data and then plot the mean/standard deviation relationship after the transformation.\n\n# Transform the data with a log2 transform (watch how we create a new variable for it)\nlog2dds &lt;- cpm(dds, log=TRUE)\n\n\nlog2dds %&gt;% quantile()\n\n       0%       25%       50%       75%      100% \n 4.196226  6.533113  8.032246  9.339823 14.817662 \n\napply(log2dds, 1, sd) %&gt;% quantile()\n\n       0%       25%       50%       75%      100% \n0.3110070 0.9600368 1.2826842 1.6385618 3.8225115 \n\napply(log2dds, 1, mean) %&gt;% quantile()\n\n       0%       25%       50%       75%      100% \n 5.473874  6.704483  7.623939  8.872750 14.010599 \n\n\n\n# Check out the transformed values (notice how we now have floating point values)\nhead(log2dds)\n\n\n\n\n\n\n\nSQ_2157\nSQ_1990\nSQ_2010\nSQ_2163\nSQ_2204\nSQ_2212\nSQ_2216\nSQ_2222\nSQ_2288\nSQ_2303\nSQ_2298\nSQ_2145\nGSM2058021\nGSM2058022\nGSM2058023\n\n\n\n\nreg_6364\n7.391532\n4.693150\n4.543824\n9.153524\n4.628941\n6.767372\n5.165425\n6.760853\n7.004273\n7.943201\n8.427468\n6.853782\n8.879940\n8.269220\n9.350105\n\n\nreg_6365\n9.000603\n7.873964\n7.923632\n8.147764\n9.196486\n8.964709\n8.426038\n8.715365\n8.332118\n8.079257\n8.304934\n8.189953\n8.777787\n8.961506\n9.568881\n\n\nreg_6366\n5.087972\n6.829712\n4.543824\n5.620275\n4.628941\n4.467208\n4.451886\n6.118166\n4.293732\n4.757775\n8.367501\n5.324762\n8.506873\n8.625283\n9.222714\n\n\nreg_6367\n5.087972\n4.693150\n4.543824\n7.076313\n5.112776\n6.860139\n5.422542\n5.751377\n4.605370\n4.757775\n8.567309\n9.542125\n9.498622\n9.192004\n9.372787\n\n\nreg_6368\n5.087972\n4.693150\n7.144706\n6.808420\n6.210186\n6.446814\n5.830150\n4.503405\n6.063995\n6.242883\n6.523221\n6.499337\n6.208006\n7.738227\n7.699948\n\n\nreg_6369\n11.787271\n11.711810\n10.837456\n11.889581\n11.428188\n11.880287\n11.678379\n11.734101\n11.216369\n11.672566\n12.841337\n12.872236\n13.355543\n13.721191\n13.701438\n\n\n\n\n\n\n\n\nhead(counts) %&gt;% kbl() %&gt;% kable_styling()\n\n\n\n\n\nSQ_2157\nSQ_1990\nSQ_2010\nSQ_2163\nSQ_2204\nSQ_2212\nSQ_2216\nSQ_2222\nSQ_2288\nSQ_2303\nSQ_2298\nSQ_2145\nGSM2058021\nGSM2058022\nGSM2058023\n\n\n\n\nreg_6364\n8\n1\n1\n97\n1\n13\n3\n12\n24\n19\n47\n4\n85\n34\n185\n\n\nreg_6365\n26\n20\n27\n47\n58\n67\n47\n52\n65\n21\n43\n11\n79\n56\n216\n\n\nreg_6366\n1\n9\n1\n6\n1\n1\n1\n7\n1\n1\n45\n1\n65\n44\n169\n\n\nreg_6367\n1\n1\n1\n21\n2\n14\n4\n5\n2\n1\n52\n29\n132\n66\n188\n\n\nreg_6368\n1\n1\n15\n17\n6\n10\n6\n1\n11\n5\n11\n3\n11\n23\n56\n\n\nreg_6369\n184\n304\n215\n661\n278\n519\n466\n435\n500\n267\n1045\n297\n1950\n1562\n3860\n\n\n\n\n\n\n\n\n# let's plot the transformed values\nmeanSdPlot(log2dds)\n\n\n\n\n\n\n\n\n\nIt is clear how regions with high mean signal (on the right) are now comparable in terms of standard deviation to regions with lower mean signal (on the left). Normally this plot should look slightly different in terms of density, but remember that we are considering only a subset of the dataset.\n\n\nAfter the transformation, the genes with the same mean do not have exactly the same standard deviations, but the experiment-wide trend (of variance over mean) has flattened.The genes with variance above the trend will allow us to cluster samples into interesting groups."
  },
  {
    "objectID": "ChIP-seq_analysis/pages/ChIP-seq_analysis_part1.html#assessing-sample-to-sample-relationships",
    "href": "ChIP-seq_analysis/pages/ChIP-seq_analysis_part1.html#assessing-sample-to-sample-relationships",
    "title": "ChIP-seq_analysis_part1",
    "section": "Assessing Sample-to-sample Relationships",
    "text": "Assessing Sample-to-sample Relationships\nOne way to understand trends in our data and the presence of poor quality or outlier samples is to perform exploratory analyses and visualize the results.\nOf particular interest is the presence of technical effects in the experiment, such as batch effects.\nIn R in general, data visualization is aided by the presence of many packages which can handle diverse data visualization tasks (from traditional plots to visualizing tabular data through heatmaps). We will use two of these packages, one is ggplot2 and the other one is pheatmap.\n\nHierarchical clustering\nOne of the main strategies for checking the consistency of our dataset is to cluster samples based on their complete H3K27 acetylation profile (considering all 1490 genomic regions in our dataset). This will allow us to spot the presence of outliers in the data and look for consistent profiles of H3K27ac across biological replicates, which we expect. Use the code below to plot a heatmap of normalized (and transformed) count values for our samples. Since plotting the full count table can be computationally expensive, we might want to subset it to the 200 genomic regions with stronger H3K27ac signal in the dataset.\n\nlibrary(\"pheatmap\")\n\n# Take the top 200 genomic regions with the highest mean in the dataset. Returns the index of regions with the highest mean across samples.\nselect &lt;- order(rowMeans(log2dds),\n                decreasing=TRUE)[1:200] # Select number of regions. \n\n# Create another table for annotating the heatmap with colors\ndf &lt;- as.data.frame(samples[,c(\"groups\",\"Tissue\")])\n\n# Draw the heatmap using the `pheatmap` package\npheatmap(log2dds[select,], cluster_rows=FALSE, show_rownames=FALSE,\n         cluster_cols=TRUE, annotation_col=df)\n\n\n\n\n\n\n\n\n\nWhat type of assessment would you make about the consistency of the samples across these top active 200 regions ? Do they cluster (a synonym for similar) based on the biological condition of our interest?\n\n\n\nSample-to-sample Distances\nAnother way to get a sense of the global relationship between samples is to check for how distant samples are between themselves. This analysis of pairwise distances looks at the acetylation signal of all 1490 genomic regions in the dataset and determines which samples have a more or less similar or different signal value for each. We expect biologically similar samples to have little difference.\n\n\nPairwise clustering using Euclidean distances\n\nlibrary(RColorBrewer)\n\n# Compute distances\nsampleDists &lt;- dist(t(log2dds))\n\n# Organize\nsampleDistMatrix &lt;- as.matrix(sampleDists)\n\ncolors &lt;- colorRampPalette( rev(brewer.pal(9, \"Blues\")) )(255)\n\n# Plot with `pheatmap`\npheatmap(sampleDistMatrix,\n         clustering_distance_rows=sampleDists,\n         clustering_distance_cols=sampleDists,\n         color = colors,\n         annotation_col = df\n         )\n\n\n\n\n\n\n\n\n\n💡 What type of assessment would you make about the heatmap you just produced? Is the analysis highlighting biologically relevant differences in the dataset?\n\n\n\nUsing RColorBrewer palettes\n\n# Draw the color palettes associated to RColorBrewer\ndisplay.brewer.all()\n\n\n\n\n\n\n\n#display.brewer.pal(n = 8, name = 'RdBu')\nbrewer.pal(n = 8, name = 'RdBu')\n\n[1] \"#B2182B\" \"#D6604D\" \"#F4A582\" \"#FDDBC7\" \"#D1E5F0\" \"#92C5DE\" \"#4393C3\"\n[8] \"#2166AC\"\n\n\n\n\nDimensionality reduction with Principal Component Analysis (PCA)\nAnother useful approach for understanding the main variability axes in our data is to perform PCA and plot the results. PCA takes our H3K27Ac data and outputs its principal components, which encode the main sources of variability in the data. Ideally, we want the samples to have variability caused by the biological effect of our interest (in this case the differences between normal colon and tumor organoids), but this might not be the case. By plotting and annotating the points by different covariates (i.e. subject or condition) we are able to understand where the variability comes from and if there is any detectable batch effect. Use the code below to generate a scatter plot of PCA coordinates and annotate them to understand what causes the variability in the data.\n\nlibrary(ggplot2)\n\n# Calculate principal components and percentage of variance\npcs &lt;- prcomp(log2dds, scale = TRUE)\npercentVar &lt;- round(100 * summary(pcs)$importance[2,])\npcaData &lt;- as.data.frame(pcs$rotation) %&gt;% merge(samples, by=0)\n\n\n# Look at the summary of the pcs object\nsummary(pcs)\n\nImportance of components:\n                          PC1    PC2     PC3     PC4     PC5     PC6     PC7\nStandard deviation     2.9465 1.5096 0.76219 0.72368 0.68918 0.61819 0.59742\nProportion of Variance 0.5788 0.1519 0.03873 0.03491 0.03166 0.02548 0.02379\nCumulative Proportion  0.5788 0.7307 0.76945 0.80437 0.83603 0.86151 0.88530\n                           PC8     PC9    PC10    PC11    PC12    PC13    PC14\nStandard deviation     0.55961 0.55433 0.50767 0.48353 0.45745 0.44858 0.32425\nProportion of Variance 0.02088 0.02049 0.01718 0.01559 0.01395 0.01342 0.00701\nCumulative Proportion  0.90618 0.92666 0.94385 0.95943 0.97338 0.98680 0.99381\n                          PC15\nStandard deviation     0.30476\nProportion of Variance 0.00619\nCumulative Proportion  1.00000\n\n\n\n# Plot (this time with ggplot2!!)\nggplot(pcaData, aes(PC1, PC2, color=groups)) +\n  geom_point(size=3) +\n  xlab(paste0(\"PC1: \",percentVar[1],\"% variance\")) +\n  ylab(paste0(\"PC2: \",percentVar[2],\"% variance\")) + \n  theme_linedraw()+\n  theme(aspect.ratio=1)\n\n\n\n\n\n\n\n\n\n💡 What can you say about this PCA? Are the samples positioning themselves based on their biological condition? How does this information relate to the other plots we produced above? Can you project both the Patient ID and the groups levels on the PCA space?"
  },
  {
    "objectID": "ChIP-seq_analysis/pages/ChIP-seq_analysis_part1.html#differential-analysis",
    "href": "ChIP-seq_analysis/pages/ChIP-seq_analysis_part1.html#differential-analysis",
    "title": "ChIP-seq_analysis_part1",
    "section": "Differential analysis",
    "text": "Differential analysis\nNow that we have plotted all the main diagnostic information related to the dataset, we can start thinking about testing for differentially active enhancer regions.\nThe main concept behind it is to contrast tumor from normal organoids and check which enhancer regions are predominantly (defined in a statistical sense) enriched for H3K27ac in one condition as opposed to the other. Remember that this is a proxy for enhancer activity. We have already given instructions to edgeR on which comparison to perform through the design formula when we created the DGEList object called dds.\n\nIn case your dataset has a source of variability due to batch effect or other factors, the design formula is the right place where you can define whether you want to correct for these possible uniteresting differences. For instance, if you found that in your dataset part of the variability is due to the different patients from which the biological replicates come from, but you want to assess other biologically driven differences due to a certain treatment, you could modify your design formula in order to check differences due to the treatment, while controlling simultaneously for patient-to-patient variability.\n\n\n\nSource\n\n\nIn this case, the design formula would be something similar to:\n\n\n# Design formula that takes into account also variability across patients\n~ Patient + Treatment\n\n\nThis design formula works ideally if your dataset is paired, that is, there is equal contribution for all the patients to the contrasted condition (i.e., the treatment).\n\nOur design that we previously built is actually an object of “matrix” data type, which is similar to a data.frame object.\n\nThe main difference between matrices and data frames is that matrices store only a single class of data, while data frames can consist of many different classes of data. You can also think about matrices as vectors that additionally contain the dimension attribute.\n\nWe can inspect more closely the design matrix:\n\ndesign\n\n\n\n\n\n\n(Intercept)\nsample_groupK_org\n\n\n\n\n1\n1\n\n\n1\n1\n\n\n1\n1\n\n\n1\n1\n\n\n1\n1\n\n\n1\n1\n\n\n1\n1\n\n\n1\n1\n\n\n1\n1\n\n\n1\n1\n\n\n1\n0\n\n\n1\n0\n\n\n1\n0\n\n\n1\n0\n\n\n1\n0\n\n\n\n\n\n\n\nIf we take a look at it we can see how the second column of this matrix is the one related to our comparison of interest, in particular to the tumor condition that we want to compare against the reference group of the normal condition.\n\nThe design matrix typically consists of binary values, where ‘1’ represents the samples of interest (tumor condition), and ‘0’ represents the reference group (normal condition). This binary setup allows us to construct a contrast between the two conditions.\n\n\nThe Main edgeR Function\nLet’s perform differential expression analysis with edgeR on our dataset using the main function for the task in the package, glmTest(). Without going into the mathematical details, this function fits a generalized linear model (GLM) to the data in order to perform inference and decide which genomic regions have a statistically significant difference in H3K27ac signal.\n\nGLMs are an extension of classical linear models to non-normally distributed data, and are used to specify probability distributions according to their mean-variance relationship.\n\nTo make statistical inferences, we need to properly account for the biological variability that adds extra noise beyond pure sampling randomness or technical variability. This overdispersion (variance grows faster than the mean or more spread than expected by the mean) can be modeled by a Negative Binomial distribution. Thus, using negative binomial modeling we can compute the probability of seeing a certain count, depending on the expected mean and how much the counts vary between replicates.\nWe first need to compute region-wise dispersion estimates with the function estimateDisp(). We can visually inspect the fit of the dispersion estimates below.\n\n# First we fit region-wise dispersion estimates to accomodate the theoretical assumptions of the model\ndds &lt;- estimateDisp(dds, design, robust=TRUE)\n\n# Plot the fitted dispersion values\nplotBCV(dds)\n\n\n\n\n\n\n\n\nFrom the dispersion estimate we can see that we are capturing and modelling efficiently the region-wise dispersion in the dataset which is intrinsically present due to variation. This variation is quantified in edgeR with a BCV or a Biological Coefficient of Variation which generally takes into account both unwanted biological variability (that you can specify in the design) and technical variation.\nNow that we have estimated dispersion of the data, we can start from the raw count data to assess statistically significant differences.\n\nTherefore, we will not use normalized and transformed data, but we know that edgeR will perform internally the normalization when performing the differential testing.\n\nGiven raw counts, NB dispersion(s) and a design matrix, glmFit() fits the negative binomial GLM and produces an object of class DGEGLM with some new components. This DGEGLM object can then be passed to glmLRT() to carry out the likelihood ratio test.\n\n# Fit the GLM\nfit &lt;- glmFit(dds, design)\n\n# Perform differential testing given the design formula we wrote previously\nlrt &lt;- glmLRT(fit, coef=2)\n\n\nThe reason why we specified coef=2 in the code above is because we are referring to the 2nd column of the design matrix, the one contrasting tumor versus normal samples."
  },
  {
    "objectID": "ChIP-seq_analysis/pages/ChIP-seq_analysis_part1.html#extracting-and-examining-results",
    "href": "ChIP-seq_analysis/pages/ChIP-seq_analysis_part1.html#extracting-and-examining-results",
    "title": "ChIP-seq_analysis_part1",
    "section": "Extracting and examining results",
    "text": "Extracting and examining results\nAfter having used the main edgeR function, we can actively explore the results of the analysis for the comparisons of our interest. We can later filter the results based adjusted P-value used to accept or reject the null hypothesis (\\(H_{0}\\)) of a genomic region NOT being differentially enriched between the two conditions.\nWith the code below we can extract a table that we call res which contains the results for every single enhancer, stored in separate rows.\n\n# Extract the results\nres &lt;- as.data.frame(lrt$table)\n\nWe can now check out our results object, which will be a data.frame, a table.\n\n# Check out results object\nhead(res, 10)\n\n\n\n\n\n\n\nlogFC\nlogCPM\nLR\nPValue\n\n\n\n\nreg_6364\n-1.4943851\n7.812858\n3.916181\n0.0478234\n\n\nreg_6365\n-0.3455046\n8.651352\n0.681276\n0.4091477\n\n\nreg_6366\n-3.6917987\n7.187410\n27.092621\n0.0000002\n\n\nreg_6367\n-3.9379829\n7.907521\n40.470868\n0.0000000\n\n\nreg_6368\n-1.1175852\n6.537113\n3.700392\n0.0543997\n\n\nreg_6369\n-1.7393659\n12.442966\n36.882154\n0.0000000\n\n\nreg_6370\n-0.8737474\n8.181011\n1.578901\n0.2089190\n\n\nreg_6371\n-1.7123683\n12.205290\n31.240509\n0.0000000\n\n\nreg_6372\n-3.3769355\n7.095959\n18.885159\n0.0000139\n\n\nreg_6373\n-0.9411323\n10.468915\n5.458547\n0.0194728\n\n\n\n\n\n\n\nThis table shows the log-fold change levels of enrichment/depletion of histone mark in our genomic regions. Keep in mind that a log-fold change of 1 corresponds to a difference in raw gene expression value of 2 times since the log has a base of 2. So, to recap, all of the enhancers with log-fold change of 1 or more are twice as enriched in H3K27ac in one condition compared to the other and we will later filter regions based on the fold-change value.\nAdditionally, we can see the Likelihood Ratio, (“LR”) for each region. This is another statistical measure used in edgeR used to assess significance: higher LR values indicate stronger evidence against the null hypothesis of no difference between conditions.\nWe can additionally print out a summary of the results of the differential analysis at a P-value &lt; 0.01 by using the following code:\n\nsummary(decideTests(lrt, p.value = 0.01))\n\n       sample_groupK_org\nDown                 149\nNotSig              1184\nUp                   157\n\n\nHere we can see (1) the type of comparison we are performing (vs the reference, in our case normal colon crypts), (2) the number of genomic regions with significantly higher (“Up”) signal in tumor organoids and the number of regions with significantly lower signal in tumor organoids (i.e., higher signal in normal condition).\nSave the results of the differential analysis\n\nres %&gt;% \n  tibble::rownames_to_column(var='PeakID') %&gt;%\n  write.table(., '../results/res_chr12.csv', col.names = TRUE, row.names = FALSE, quote = FALSE, sep = '\\t')\n\n\nVisualizing Results With MD Plots\nMD plots are used to get a sense of the proportions of up- and down-regulated features between two conditions and the number of counts per million (CPM) of each feature, to check if regions with higher counts are statistically preferred to be also differential.\n\n# Plot the MD Plot \n# abline() enables you to draw straight lines on a plot\nplotMD(lrt)\nabline(h=c(-1, 1), col=\"gray\")\n\n\n\n\n\n\n\n\nWith the gray line we indicate a fold-change of +/- 1 which, if you recall, stands for an actual magnitude of change of value 2.\n\n\nVisualizing results with volcano plots\nResults from a differential analysis can actually be visualized in many ways, in order to emphasize different messages of interest within them. One popular way is to associate statistical significance (P-value) and magnitude of effect (fold change) related to each region in the dataset for the specific comparison we are evaluating.\n\nThis is also the way results have been visualized in the paper from our study.\n\nLet’s plot a scatterplot, called “volcano” for the typical vulcanic shape, to summarize the results, also adding some thresholds to P-values and log-fold changes.\n\nvolcano_corr &lt;- res %&gt;%\n    mutate( threshold=ifelse(logFC &gt;= 2 & PValue &lt; 0.01,\"A\", \n                             ifelse(logFC &lt;= -2 & PValue &lt; 0.01, \"B\", \"C\"))\n    )\n\nvolc_plot &lt;- ggplot(volcano_corr, aes(x=logFC, y =-log10(PValue), color=threshold)) +\ngeom_point(alpha=0.4, size=1) +\nscale_color_manual(values=c( \"A\"=\"#D90416\",\"B\"=\"#033E8C\", \"C\"=\"grey\")) +\nxlab(\"log2(Fold Change)\") + ylab(\"-log10(adj p-value)\") +\ntheme_classic() +\ntheme(legend.position=\"none\") +\ngeom_hline(yintercept = 2, colour=\"#990000\", linetype=\"dashed\") + \ngeom_vline(xintercept = 2, colour=\"#990000\", linetype=\"dashed\") + \ngeom_vline(xintercept = -2, colour=\"#990000\", linetype=\"dashed\") +\nscale_y_continuous(trans = \"log1p\")\n\nvolc_plot\n\n\n\n\n\n\n\n\n\n\nVisualizing results with heatmaps\nWe can also plot differentially enriched regions in the two conditions of our interest using heatmaps. In this case we select genomic intervals based on their significance (P-value &lt; 0.01) and visualize how their H3K27ac values change across samples just like we have done earlier.\n\n# Take differential regions\ndiffs &lt;- rbind(volcano_corr[volcano_corr$threshold == \"A\",], volcano_corr[volcano_corr$threshold == \"B\",]) %&gt;% rownames()\n\n# Subset matrix for regions of interest\nmtx &lt;- cpm(dds)[diffs,]\n\n# Create another table for annotating the heatmap with colors\ndf &lt;- as.data.frame(samples[,c(\"groups\"), drop=FALSE])\n\ndiff_heat &lt;- pheatmap(mtx, cluster_rows=TRUE, show_rownames=FALSE,cluster_cols=TRUE, annotation_col=df, scale = \"row\")\ndiff_heat\n\n\n\n\n\n\n\n\n\n\nVisualizing results with violin and box plots\nLast, we can visualize the results by looking at the distribution of counts aggregated across conditions. We can plot the counts specifically for genomic regions up-regulated in tumor compared to normal condition and use a violin plot together with a box plot. The box plot highlights the interquartile range and the median of the data, while the volcano also show the kernel probability density of the data at different values.\n\n# Extract up-regulated regions which correspond to all the dots in the right part of the volcano\nup_regions &lt;- rownames(volcano_corr[volcano_corr$threshold == \"A\",])\n\n# Extract normalized and log-scaled counts for up-regulated regions\nup_mtx &lt;- cpm(dds, log=TRUE, normalized.lib.sizes = TRUE)[up_regions,]\n\n# Merge information about samples with the counts in order to group counts based on the condition of interest\nmerged_long_up_mtx &lt;- pivot_longer(as.data.frame(up_mtx), cols = everything(), names_to = 'id') %&gt;% merge(samples, by.x = 'id', by.y = 0)\n\n# Make the plot with ggplot2\nviolins &lt;- ggplot(merged_long_up_mtx, aes(groups, value, fill = groups)) + geom_violin(trim=FALSE) + \n  geom_boxplot(fill='white', width=0.1) + \n  theme_classic() + \n  ylab('log CPM')\n\nviolins\n\n\n\n\n\n\n\n\n\n\nSave dds object\nLet us save the object in case we need to retrieve it later on.\n\n# Check the environment\ngetwd()\n\n\nsaveRDS(dds, '../results/dds_object.rds')"
  },
  {
    "objectID": "IntroGR/pages/Intro_to_R.html",
    "href": "IntroGR/pages/Intro_to_R.html",
    "title": "Introduction to R",
    "section": "",
    "text": "Introduction to R and RStudio\nSetting up the R environment\nWorking with R objects\nInstall, and use R packages and functions\nAnalysis of genomic data using GRanges"
  },
  {
    "objectID": "IntroGR/pages/Intro_to_R.html#objectives",
    "href": "IntroGR/pages/Intro_to_R.html#objectives",
    "title": "Introduction to R",
    "section": "",
    "text": "Introduction to R and RStudio\nSetting up the R environment\nWorking with R objects\nInstall, and use R packages and functions\nAnalysis of genomic data using GRanges"
  },
  {
    "objectID": "IntroGR/pages/Intro_to_R.html#omics-experiments",
    "href": "IntroGR/pages/Intro_to_R.html#omics-experiments",
    "title": "Introduction to R",
    "section": "Omics experiments",
    "text": "Omics experiments\n‘Omics’ as disciplines work to answer questions regarding specific ‘omes’. These questions are enabled by omics experiments; in most cases, these will be sequencing- or mass-spectrometry based.\nThe identification of a suitable model, types and numbers of samples, the process of extraction and purification of our target ‘ome’, and finally its reformulation into a sequenceable product, i.e. a library, shape the final bioinformatic dataset and place limits on the possible questions we will be able to ask of it.\n\nFor example, in the case of RNA-seq, phenol-based extraction and precipitation will yield results that are not always comparable with total RNA extraction with a spin column. Even more, the contingent decision to perform ribodepletion or enrichment for polyadenylated transcript will have an impact even on simple gene expression analyses.\n\nSumming up, an Omics experiment is designed starting from a question, selecting the sample(s), wet lab procedure and library preparations that will enable the most truthful, informative dataset to be built.\n\n\n\n\nDesigning Omics experiments: from question to dataset"
  },
  {
    "objectID": "IntroGR/pages/Intro_to_R.html#why-learn-r",
    "href": "IntroGR/pages/Intro_to_R.html#why-learn-r",
    "title": "Introduction to R",
    "section": "Why learn R?",
    "text": "Why learn R?\nR is a programming language built for statistical computing, data exploration, and graphical representation. Developed by Ross Ihaka and Robert Gentleman in the early 1990s, it has grown to be widely adopted in academia, research, and various data-focused industries.\n\n\n\n\nhttps://aarababdellah.medium.com/what-is-r-programming-language-used-for-f600895e0416\n\n\n\nKey features and advantages of R:\n\nStatistical analysis\nData Exploration and Visualization\nVibrant community of scientists, developers, users\nExtensive Package Ecosystem\nReproducible Research\nIntegration with Other Languages\nLearning Resources and Documentation"
  },
  {
    "objectID": "IntroGR/pages/Intro_to_R.html#setting-up-rstudio",
    "href": "IntroGR/pages/Intro_to_R.html#setting-up-rstudio",
    "title": "Introduction to R",
    "section": "Setting up Rstudio",
    "text": "Setting up Rstudio\nFirst of all, let’s start assembling the tools that you will need for this workshop! While R by itself has no particular user interface, RStudio is the tool that allows you to click and actually ‘see’ what you are doing. RStudio is an integrated development environment (IDE) and will be our primary tool to interact with R.\nYou can follow two strategies:\n\nInstall R and RStudio on your machine\nRun RStudio in a browser using RStudio Cloud.\n\nNote that the first option will require a bit more time and effort. To get started with RStudio Cloud (now Posit Cloud), click on this link and create a Posit free account. Once you completed your registration, you are redirected to Your Workspace. To start a new R project, you can click on New Project &gt; New RStudio Project. This will open RStudio on the Cloud."
  },
  {
    "objectID": "IntroGR/pages/Intro_to_R.html#the-rstudio-interface",
    "href": "IntroGR/pages/Intro_to_R.html#the-rstudio-interface",
    "title": "Introduction to R",
    "section": "The RStudio Interface",
    "text": "The RStudio Interface\nNow that you have RStudio open, you should see something similar to this:\n\n\n\nThe RStudio interface is composed of quadrants:\n\nThe Console window: located in the bottom-left, it’s where you will find the output of your coding, and it’s also possible to type R code interactively on the console.\nThe Files / Plots / Packages / Help / Viewer window: located in the bottom-right, it displays your current file system, which is pointed to the position where your Rproject you just created lives.\n\nThe Files pane lists the files and folders in your root directory (i.e. where by default RStudio saves your analyses).\nAnother important pane is Plots, designed to show you any plots you have created.\nThe Package pane instead allows to manage all the additional tools you can import and use when you perform your analyses. They are useful to enhance the basic R functions from different aspects.\nIf you need H E L P, you can use the Help pane: you can search for specific topics, for instance how a computation works and other kinds of documentation.\n\nThe Environment / History / Connections / Tutorial window: you can find it in the top right position.\n\nIt is pointed to the Environment pane, that is a place where you can find all the objects available for computation (e.g. datasets, plots, lists, etc.).\nThe History pane keeps whatever computation you run in the console. You can re-run the computation stored in the history (double click or copy-paste) and you can also copy the past code into an existing or new R Script."
  },
  {
    "objectID": "IntroGR/pages/Intro_to_R.html#r-fundamentals",
    "href": "IntroGR/pages/Intro_to_R.html#r-fundamentals",
    "title": "Introduction to R",
    "section": "R fundamentals",
    "text": "R fundamentals\n\nBasic computations\nThe most basic computation you can do in R is arithmetic operations. Let’s take a look at the following examples:\n\n# Addition\n14 + 7\n\n[1] 21\n\n# Division\n14 / 7\n\n[1] 2\n\n# Square root\nsqrt(14)\n\n[1] 3.741657\n\n\nBut R is much more than an enormous calculator! Besides arithmetic operations, there are also logical queries you can perform. Logical queries always return either the value TRUE or FALSE.\n\n#1 Is it TRUE or FALSE?\n3 == 3\n\n[1] TRUE\n\n#2 Is 45 bigger than 55?\n50 &gt; 56\n\n[1] FALSE\n\n#3 Are these two words NOT the same?\n\"Gene\" != \"gene\"\n\n[1] TRUE\n\n\n\nNotice that in logical queries, equal to is represented by == and not by = , which instead is used to assign a value to an object. However, in practice, most R programmers tend to avoid = since it can easily lead to confusion with ==.\n\nBelow is a list of logical operators commonly used in R\n\n\n\n\n\nAssigning values to objects\nAssigning values to objects with &lt;- is a common task. What can be an object ?\n\na list of names\na series of number\na dataset\na plot\na function\netc.\n\nIn short, an object can enclose different things which form part of your data analysis. For example, objects are useful to store results that you want to process further in later steps of the analysis. We have to use the assign operator &lt;- to assign a value to an object. Let’s have a look at an example:\n\n# Let's assign the gene \"TP53\" to the \"genes\" object\ngenes &lt;- \"TP53\"\n\nNow the object genes carries the value \"TP53\". If you check out the Environment pane, you should see that the gene object appeared there. We can also print values of an object in the console by simply typing the name of the object genes and hit Return ↵.\n\n# What are my genes?\ngenes\n\n[1] \"TP53\"\n\n\nTo create objects with multiple values, we can use the function c() which stands for ‘concatenate’:\n\n# Adding some more genes to the object\ngenes &lt;- c(\"TP53\",\n           \"TNF\",\n           \"EGFR\",\n           \"VEGFA\",\n           \"APOE\",\n           \"IL6\")\n           \n# Here are my genes\ngenes\n\n[1] \"TP53\"  \"TNF\"   \"EGFR\"  \"VEGFA\" \"APOE\"  \"IL6\"  \n\n\nTo concatenate values into a single object, we need to use a comma , to separate each value. Otherwise, R will report an error back.\n\ngenes &lt;- c(\"TP53\" \"TNF\")\n\nDon’t worry about it! R’s error messages tend to be very useful and give meaningful clues to what went wrong. In this case, we can see that something ‘unexpected’ happened and it shows where our mistake is.\nStoring numerical data in variables\n\n20 -&gt; x\n\ny &lt;- 5\n\nx + y\n\n[1] 25\n\n\nRules and guidelines in naming variables\n\nMade up of letters, numbers, dots, underscores\nCannot begin with a number or underscore\nUse informative names where possible\nOpt for lower case\nSeparate words with dots of underscores\n\n\n_x &lt;- 2\n\nError in parse(text = input): &lt;text&gt;:1:2: unexpected symbol\n1: _x\n     ^"
  },
  {
    "objectID": "IntroGR/pages/Intro_to_R.html#object-types-data-structures",
    "href": "IntroGR/pages/Intro_to_R.html#object-types-data-structures",
    "title": "Introduction to R",
    "section": "Object types (Data Structures)",
    "text": "Object types (Data Structures)\n\n\n\n\nVectors\nThe most basic unit in R. They contain sets of values of the same data type:\n\nNumeric\nInteger\nCharacter (text)\nLogical (TRUE or FALSE)\n\nThe object genes we created before is a character vector.\nCan you tell the difference in the elements of the following vectors?\n\nx &lt;- c(1 ,2, 3)\nx\n\n[1] 1 2 3\n\ny &lt;- c(1,2,4,\"hello\")\ny\n\n[1] \"1\"     \"2\"     \"4\"     \"hello\"\n\n\n\nWhat happens if you mix data types inside a vector? R generates a resulting vector with a mode that best fits all its elements. The process of converting between different storage modes is known as “coercion”.\n\nUseful functions for creating vectors:\n\nrep: replicate elements of vectors and lists\nseq: sequence generation\nstatistical distributions (e.g. rnorm, rpois etc)\n\n\nrep(c(\"hello\", \"ciao\"), times=2)\n\n[1] \"hello\" \"ciao\"  \"hello\" \"ciao\" \n\nrep(c(\"hello\", \"ciao\"), each=2)\n\n[1] \"hello\" \"hello\" \"ciao\"  \"ciao\" \n\n?rep\n\n\nseq(from=2, to=10, by=2)\n\n[1]  2  4  6  8 10\n\n\nIn vectorised operations equivalent positions are matched and shorter vectors are recycled.\n\n# Operation to a single element\nc(1,2,3) * 2\n\n[1] 2 4 6\n\n# Operation between two vectors \nc(1,2,3) + c(4,5,6)\n\n[1] 5 7 9\n\n# Shorter vector is recycled\nc(1,2,3) + c(4,5)\n\n[1] 5 7 7\n\n\n\n\nShorter vector is recycled\n\n\n\n\nLists\nValues inside objects are meant to be of the same type, for instance numeric or character. Consequently, mixing different types of data into one object is likely a bad idea. However, there is an exception: a list object can hold other objects of different data types, e.g. it represents a collection of vectors.\nLists are highly useful within functions in R. We can combine various types of results into a single list to return them together.\nElements of a list can be named (names attribute).\n\ndata &lt;- list(genes = genes,\n             counts = c(1, 2, 3, 4),\n             metadata = c(\"TGFB1\", 5, \"AKT1\", 6))\ndata\n\n$genes\n[1] \"TP53\"  \"TNF\"   \"EGFR\"  \"VEGFA\" \"APOE\"  \"IL6\"  \n\n$counts\n[1] 1 2 3 4\n\n$metadata\n[1] \"TGFB1\" \"5\"     \"AKT1\"  \"6\"    \n\n\n\nYou will notice in this example that we do not use \"\" for each value in the list. This is because genes is not a character value, but an object. When we refer to objects, we do not need quotation marks.\n\nLooking at the list item in the environment page, you can see that the object data is classified as a List of 3, and if you click on the blue icon, you can inspect the different objects inside.\n\n\n\nElements are indexed by double brackets but they can also be referenced by the $ notation when named.\n\n# Retrieve \ndata$genes\n\n[1] \"TP53\"  \"TNF\"   \"EGFR\"  \"VEGFA\" \"APOE\"  \"IL6\"  \n\ndata[[2]]\n\n[1] 1 2 3 4\n\ndata[1]\n\n$genes\n[1] \"TP53\"  \"TNF\"   \"EGFR\"  \"VEGFA\" \"APOE\"  \"IL6\"  \n\n\n\n\nData frames\nThe data.frame structure is one of the most abundantly used in R. Think of data.frames as the R equivalent of Excel spreadsheets, so a way to store tabular data. As we will see later, pretty much all the data we are going to handle will be in the form of a data.frame or some of its other variations.\n\n# Let's create and display a data frame (a table) with four rows and two columns\ndf &lt;- data.frame(\"Class\"=c(\"a\",\"b\",\"c\",\"d\"), # First column\n            \"Quantity\"=c(1,10,4,6)) # Second column\ndf\n\n  Class Quantity\n1     a        1\n2     b       10\n3     c        4\n4     d        6\n\n\nWe have instructed R to create a data.frame object. We will give more of these commands from now on!\n\n\nObject Attributes\nObjects have attributes that we can retrieve with psecialized functions:\n\nclass\nlength\ndim\nnames\nattributes\n\nHow can we check what kind (“class”) of object we have?\n\nclass(genes)\n\n[1] \"character\"\n\nclass(data)\n\n[1] \"list\"\n\n\n\nnames(data)\n\n[1] \"genes\"    \"counts\"   \"metadata\"\n\n\n\n\nFunctions\nWe mention the term ‘function’ multiple times, but what are functions and why we need them? In simple terms, functions are objects that contain lines of codes and can be seen as shortcuts for our programming. Functions are useful for repeating several operations across multiple datasets with a single command. They save space and time, making our code more readable and reliable. We will make an example to understand better, by calculating the arithmetic mean:\n\n# We create an object that stores our values\nvalues &lt;- c(1, 5, 7, 4, 13, 2, 9, 5)\n\n# Manually compute the sum \nsum &lt;- 1 + 5 + 7 + 4 + 13 + 2 + 9 + 5\n\n# Divide the sum by the number of values\nmean &lt;- sum / 8\nmean\n\n[1] 5.75\n\n\nOr…\n\n# Use the mean function that is part of the R base package\nmean(values)\n\n[1] 5.75\n\n\n\n# Let's check that the two methods coincide\nsum / 8 == mean(values)\n\n[1] TRUE\n\n\nLet’s define the function for the above example\n\nmean_of_values &lt;- function(data) {\n  \n  mean_value &lt;- sum(data) / length(data)\n  return(mean_value)\n}\n\nmean_of_values(values)\n\n[1] 5.75\n\n\n\n\n\n\nMake your own function! If the formula to convert Fahrenheit to Celsius is as follows, how can you define a function? (32°F − 32) × 5/9 = 0°C\n\n\n💡We can also nest one function call inside another."
  },
  {
    "objectID": "IntroGR/pages/Intro_to_R.html#useful-functions-in-r",
    "href": "IntroGR/pages/Intro_to_R.html#useful-functions-in-r",
    "title": "Introduction to R",
    "section": "Useful functions in R",
    "text": "Useful functions in R\nLooking up help\n\n?sqrt\n\n\n??sqrt\n\nGet and Set working directory in R\n\n# Show the current directory\ngetwd()\n\n[1] \"/Users/mfakiola/Desktop/fakiola/BioMeTra/Lectures/MBMM/Lectures/repo_test/IntroGR/pages\"\n\n# Set the working directory\n#setwd('Users/&lt;user&gt;/')\n\n\n# Inspect the R environment \nls()\n\n [1] \"data\"                  \"df\"                    \"fahrenheit_to_celsius\"\n [4] \"genes\"                 \"mean\"                  \"mean_of_values\"       \n [7] \"sum\"                   \"values\"                \"x\"                    \n[10] \"y\"                    \n\n\n\n# Inspect files in the currect directory\nlength(list.files())\n\n[1] 3\n\nlist.files()\n\n[1] \"GRanges_gtf.Rmd\"      \"Intro_to_R.rmarkdown\" \"Intro_to_R.Rmd\"      \n\n#dir()\n\n# Verify that a file is in a directory\nlist.files('../results/')\n\n[1] \"TSS_v2.bed\"     \"TSS_window.bed\" \"TSS.bed\"       \n\n'counts_table.csv' %in% list.files('../results/')\n\n[1] FALSE"
  },
  {
    "objectID": "IntroGR/pages/Intro_to_R.html#tidyverse",
    "href": "IntroGR/pages/Intro_to_R.html#tidyverse",
    "title": "Introduction to R",
    "section": "Tidyverse",
    "text": "Tidyverse\nA collection of R packages designed for data science. It aims to overcome many structural challenges when working in R by adopting a unified design and data philosophy. The tools are designed to work together but can seamlessly integrated with the broader R ecosystem.\n\n\n\nTibble - data storage\nReadR - reading data from files\nDplyR - Manipulate and filter data\nTidyR - Model data correctly\nGgplot2 - Draw figures and graphs\nTidy data describes a standard way of storing data that is used wherever possible throughout the tidyverse.\n\nEach variable is a column; each column is a variable.\nEach observation is a row; each row is an observation.\nEach value is a cell; each cell is a single value.\n\n\n# Check if tidyverse is not already installed and installs it if the argument returns TRUE\nif (!require(\"tidyverse\", quietly = TRUE))\n  install.packages(\"tidyverse\")\n\nlibrary(tidyverse)\n\nThe default installation of R includes a variety of built-in datasets, typically used as sample data for experimenting with R functions. We will explore the main functions of dplyr and ggplot2 using the mtcars dataset.\nmtcars: Motor Trend Car Road Tests\n\nLoad a built-in R data\n\n# Check the list of built-in datasets\n#data()\n\n# Load the mtcars dataset\ndata(mtcars)\nhead(mtcars, 4)\n\n                mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4      21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag  21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710     22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive 21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\n\n\nLet’s have a look at the dataset. What attributes mtcars has?\n\n# Check the attributes of an object\nattributes(mtcars)\n\n$names\n [1] \"mpg\"  \"cyl\"  \"disp\" \"hp\"   \"drat\" \"wt\"   \"qsec\" \"vs\"   \"am\"   \"gear\"\n[11] \"carb\"\n\n$row.names\n [1] \"Mazda RX4\"           \"Mazda RX4 Wag\"       \"Datsun 710\"         \n [4] \"Hornet 4 Drive\"      \"Hornet Sportabout\"   \"Valiant\"            \n [7] \"Duster 360\"          \"Merc 240D\"           \"Merc 230\"           \n[10] \"Merc 280\"            \"Merc 280C\"           \"Merc 450SE\"         \n[13] \"Merc 450SL\"          \"Merc 450SLC\"         \"Cadillac Fleetwood\" \n[16] \"Lincoln Continental\" \"Chrysler Imperial\"   \"Fiat 128\"           \n[19] \"Honda Civic\"         \"Toyota Corolla\"      \"Toyota Corona\"      \n[22] \"Dodge Challenger\"    \"AMC Javelin\"         \"Camaro Z28\"         \n[25] \"Pontiac Firebird\"    \"Fiat X1-9\"           \"Porsche 914-2\"      \n[28] \"Lotus Europa\"        \"Ford Pantera L\"      \"Ferrari Dino\"       \n[31] \"Maserati Bora\"       \"Volvo 142E\"         \n\n$class\n[1] \"data.frame\"\n\n\nWhat do the hearders refer to?\nThe data was extracted from the 1974 Motor Trend US magazine, and comprises fuel consumption and 10 aspects of automobile design and performance for 32 automobiles (1973–74 models).\n\n\n\nmpg - Miles per Gallon cyl - # of cylinders disp - displacement, in cubic inches hp - horsepower drat - driveshaft ratio wt - weight qsec - 1/4 mile time; a measure of acceleration vs - ‘V’ or straight - engine shape am - transmission; auto=0 or manual=1 gear - # of gears carb - # of carburetors.\n\n\ndplyr\ndplyr comes with many useful functions to manipulate your data. Each function accepts a dataframe/tibble as its first argument and returns a modified dataframe/tibble. It also allows for multiple functions to run together by chaining the operations. This way we can avoid repetive coding and intermediate variables.\ninput –&gt; selection –&gt; filter –&gt; mutate –&gt; output\nThe pipe operator %&gt;% to the rescue!\ninput %&gt;% selection %&gt;% filter %&gt;% mutate\nFiltering and subsetting\n\n# Select specific columns\nmtcars %&gt;% select(mpg, cyl) %&gt;% head(2)\n\n              mpg cyl\nMazda RX4      21   6\nMazda RX4 Wag  21   6\n\nmtcars %&gt;% select(1, 2) %&gt;% head(2)\n\n              mpg cyl\nMazda RX4      21   6\nMazda RX4 Wag  21   6\n\nmtcars %&gt;% select(-mpg, -cyl) %&gt;% head(2)\n\n              disp  hp drat    wt  qsec vs am gear carb\nMazda RX4      160 110  3.9 2.620 16.46  0  1    4    4\nMazda RX4 Wag  160 110  3.9 2.875 17.02  0  1    4    4\n\n\n\n# Select rows\nmtcars %&gt;% slice(2:4)\n\n                mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4 Wag  21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710     22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive 21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\n\n\n\n# Filter a variable\nmtcars %&gt;% filter(mpg&gt;21 & hp&gt;90)\n\n                mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nDatsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive 21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\nMerc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nToyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nPorsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nVolvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\n\nLet’s create a new variable to identify cars with miles per gallon (mpg) &gt; 25\n\n# Create a new variable\nmtcars %&gt;% mutate(highmpg = ifelse(mpg&gt;25, '1', '0')) %&gt;% filter(highmpg==1)\n\n                mpg cyl  disp  hp drat    wt  qsec vs am gear carb highmpg\nFiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1       1\nHonda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2       1\nToyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1       1\nFiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1       1\nPorsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2       1\nLotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2       1\n\n\nCombining operations: Identify cars with 5 gears and horse power &gt; 100. Display the miles per gallon in descending order.\nNote, we do not create a new object here, just inspecting the output of the combined functions we perform.\n\n# Combining operations\nmtcars %&gt;% \n      mutate(hmpg_gear = ifelse(hp&gt;100 & gear==5, '1', '0')) %&gt;% \n      filter(hmpg_gear==1) %&gt;%\n      arrange(desc(mpg)) %&gt;%\n      select(mpg)\n\n                mpg\nLotus Europa   30.4\nFerrari Dino   19.7\nFord Pantera L 15.8\nMaserati Bora  15.0\n\n\nTransforming data: Long versus Wide Format\nWide Format\n\nCompact and easy to read\nNot extensible to more metadata\n\n\n\n\nLong Format\n\nMore verbose (repeated values)\nAll values in a single column\nAmenable to more metadata\nUseful for plotting\n\n\n\n\nWe use pivot_longer(), which “lengthens” data, increasing the number of rows and decreasing the number of columns. The inverse transformation is pivot_wider().\nWe will convert a subset (slice and select) of the mtcars object from wide to long format. We specify which columns we want to pivot into longer format in the cols argument. This information will be stored in the metadata column names_to. The actual values will be stored in the values_to column. cols defines a selection of columns. If empty, all variables are selected. You can supply bare variable names, select all variables between x and z with x:z, exclude y with -y.\nWe keep the rownames as a separate column.\n\n# Convert from wide to long format\nmtcars %&gt;% slice(1:4) %&gt;% select(1:4) %&gt;% \n  mutate(cars=rownames(.)) %&gt;% \n  #pivot_longer(!cars, names_to = \"keys\", values_to = \"value\")\n  pivot_longer(cols=mpg:hp, names_to = \"keys\", values_to = \"value\")\n\n# A tibble: 16 × 3\n   cars           keys  value\n   &lt;chr&gt;          &lt;chr&gt; &lt;dbl&gt;\n 1 Mazda RX4      mpg    21  \n 2 Mazda RX4      cyl     6  \n 3 Mazda RX4      disp  160  \n 4 Mazda RX4      hp    110  \n 5 Mazda RX4 Wag  mpg    21  \n 6 Mazda RX4 Wag  cyl     6  \n 7 Mazda RX4 Wag  disp  160  \n 8 Mazda RX4 Wag  hp    110  \n 9 Datsun 710     mpg    22.8\n10 Datsun 710     cyl     4  \n11 Datsun 710     disp  108  \n12 Datsun 710     hp     93  \n13 Hornet 4 Drive mpg    21.4\n14 Hornet 4 Drive cyl     6  \n15 Hornet 4 Drive disp  258  \n16 Hornet 4 Drive hp    110  \n\n\nWe first covert from wide to long format (in this cases using gather which is no longer under active development). Then we convert back to wide format.\n\n# Convert from long back to wide format\nmtcars %&gt;% slice(1:4) %&gt;% select(1:4) %&gt;% \n  mutate(cars=rownames(.)) %&gt;% \n  # Here we use gather\n  gather(keys, value, -cars) %&gt;%\n  pivot_wider(names_from = \"keys\", \n              names_prefix = \"var_\",\n              values_from = \"value\")\n\n# A tibble: 4 × 5\n  cars           var_mpg var_cyl var_disp var_hp\n  &lt;chr&gt;            &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;\n1 Mazda RX4         21         6      160    110\n2 Mazda RX4 Wag     21         6      160    110\n3 Datsun 710        22.8       4      108     93\n4 Hornet 4 Drive    21.4       6      258    110\n\n\n\nSimilar transformations can be achieved with the reshape::melt and reshape::dcast functions\n\n\n\nggplot2\nggplot is a powerful and flexible library for tidyverse. Data stored in a dataframe/tibble is passed to ggplot along with two main arguments: i) columns to be plotted, and ii) graphical representation to be displayed. Additional customization is possible.\nGeometries and Aesthetics\nGeometries are types of plot:\n\ngeom_point() Point geometry, (x/y plots, stripcharts etc)\ngeom_line() Line graphs\ngeom_bar() Barplots\ngeom_boxplot() Box plots\ngeom_histogram() Histogram plots\n\nAesthetics provide options to change the appearance of data in a plot - Using fixed values or - Linking to a column in the dataset - called an aesthetic mapping\nIn ggplot2, the x and y mappings for data points are specified within the aes() function, either in the ggplot() function or in individual geom layers. The geom determines how the data points are represented graphically (e.g., as points, lines, etc.), but the x and y values themselves are mapped to the data.\n\n\n\n\n\nHere, we create a scatter plot for two variables in the mtcar dataset and we will annotate the data based on a third variable.\n\nmtcars %&gt;% ggplot(aes(mpg, wt, colour=cyl)) + geom_point()\n\n\n\n\n\n\n\n\n\nNotice that the cyl is depicted as continuous variable. We can change this behaviour and plot it as discrete variable by converting it to a factor.\n\n\n# Check the class of cyl and convert to factor by defining the levels of the factor\nclass(mtcars$cyl)\n\n[1] \"numeric\"\n\nunique(mtcars$cyl)\n\n[1] 6 4 8\n\nmtcars %&gt;% mutate(cyl = factor(cyl, levels=unique(cyl)) ) %&gt;% pull(cyl) %&gt;% class()\n\n[1] \"factor\"\n\n#mtcars %&gt;% mutate(across(cyl, as.factor)) %&gt;% pull(cyl) %&gt;% class()\n\n\nmtcars %&gt;% mutate(across(cyl, as.factor)) %&gt;% \n        ggplot(aes(mpg, wt, colour=cyl)) + \n          geom_point()\n\n\n\n\n\n\n\n\nCan you modify the code to annotate with car labels?\n\nmtcars %&gt;% \n  mutate(across(cyl, as.factor),\n          cars=rownames(.) ) %&gt;% \n  ggplot(aes(mpg, wt, colour=cyl, label=cars)) + \n      geom_point() + \n      geom_text(vjust=1.6, hjust=0.4, size=2)\n\n\n\n\n\n\n\n\nMore exercises:\n\nMake all data points size 4 and blue, with red stroke of size 2 and size 4.\nSize according to the number of gears\n\n\nmtcars %&gt;% ggplot(aes(mpg, wt )) + geom_point(size=4, colour='red', fill='blue', shape=21, stroke=2)\n\n\n\n\n\n\n\nmtcars %&gt;% mutate(across(gear, as.factor)) %&gt;% ggplot(aes(mpg, wt, size=gear)) + geom_point(colour='red')\n\n\n\n\n\n\n\n\n\nGeometries warn when missing values have been dropped from the data set and not plotted. You can turn this off by setting na.rm = TRUE.\n\nPlotting distributions - multiple density plots\nPlot the miles per gallon density across different cylinder values\n\nmtcars %&gt;% mutate(across(cyl, as.factor)) %&gt;% \n  ggplot(aes(mpg, fill=cyl, colour = cyl)) + \n  geom_density(alpha=0.4) + \n  theme_classic() +\n  scale_fill_manual(values=c('grey','lightblue','yellow')) +\n  theme(ggtitle(\"Miles per gallon density\"),\n        legend.position=\"bottom\", \n        legend.text = element_text(size = 20), \n        legend.title = element_text(size = 15, face = 'bold'),\n        axis.title.x = element_text(size = 16),\n        axis.title.y = element_text(size = 16),\n        axis.text.y=element_text(size = 10),\n        axis.text.x=element_text(size = 10),\n        legend.key.size = unit(.4, \"cm\")) +\n  ylab('Density') +\n  xlab('Miles per gallon')\n\n\n\n\n\n\n\n\n\n💡 Perform Exploratory Data Analysis using the package explore. https://cran.r-project.org/web/packages/explore/vignettes/explore-mtcars.html"
  },
  {
    "objectID": "IntroGR/pages/Intro_to_R.html#create-an-rscript",
    "href": "IntroGR/pages/Intro_to_R.html#create-an-rscript",
    "title": "Introduction to R",
    "section": "Create an Rscript",
    "text": "Create an Rscript\nYou might want to save your code for a later use, especially when it starts to become long and complex. In this case, it is not very convenient to write it in the console, which does not keep track of it (as far as you don’t go back in the History) and does not allow to edit the code and save changes.\nSo, instead, we can write code into an R Script, which is a document that RStudio recognizes as R programming code and has .R as extension. Files that are not R Scripts, like .txt, .rtf or .md, can also be opened in RStudio, but any code written in it will not be automatically recognized.\nWhen opening an R script or creating a new one, it will display in the Source window. The term ‘source’ can be understood as any type of file, e.g. data, programming code, notes, etc.\n\nNow let’s create an R script, by selecting File &gt; New File &gt; R Script in the menu bar, or using the keyboard shortcut Ctrl + Shift + N on PC and Cmd + Shift + N on Mac. We will name it “Day1.R”.\nNow you can go in the History, copy the lines previously coded (by clicking on the first line you want to copy, then pressing Shift + Down arrow, up to the last line of code) and then click To Source.\n❗️ Writing some code in your R script will NOT automatically run it! If you tried pressing Return ↵, you would only add a new line. Instead, you need to select the code you want to run and press Ctrl+Return ↵ (PC) or Cmd+Return ↵ (Mac)."
  },
  {
    "objectID": "IntroGR/pages/Intro_to_R.html#references",
    "href": "IntroGR/pages/Intro_to_R.html#references",
    "title": "Introduction to R",
    "section": "References",
    "text": "References\n\nhttps://r.qcbs.ca/workshop01/book-en/index.html\nhttps://rstudio-education.github.io/hopr/\nhttps://www.bioinformatics.babraham.ac.uk/training.html"
  },
  {
    "objectID": "pages/index.html",
    "href": "pages/index.html",
    "title": "Course Introduction",
    "section": "",
    "text": "Welcome! This page has been created as part of the Unimi course “Medical Biotechnology and Molecular Medicine”. The aim is to introduce you to bioinformatics and to some of the most important concepts related to the analysis of Next Generation Sequencing (NGS) data.\nYou will be guided through the analytical workflows of ChIP-seq and Single cell RNA-seq datasets. The hands-on part is based on R and for this reason an essential introduction to this programming language will be provided as well.\nThe ChIP dataset used in this workshop is taken from our study published on Nature Communications in 2021, “Epigenomic landscape of human colorectal cancer unveils an aberrant core of pan-cancer enhancers orchestrated by YAP/TAZ”. Part of the exercises will be dedicated to reproducing some relevant analyses and plots published as results! The scRNA-seq workflow will be based on Seurat Tutorials found here.\n\nLearning Objectives\n\nFamiliarize with basic R functionalities\nWorking with genomic coordinates\nGet an overview of the ChIP-seq assay and its significance in genomic research\nUnderstand applications and key insights derived from ChIP-seq experiments\nDescribe the core steps of a ChIP-seq data analysis pipeline\nLearn how to navigate and utilize public resources for the analysis and exploration of genomic data\nUnderstand the key steps in scRNA-seq data analysis\n\n\n\nWorkshop Schedule\nThis workshop is intended as a three-day tutorial. Each day will be dedicated to specific activities:\n\nDay 1\n\nIntroduction to R and RStudio\nManipulate objects in R\nInstall, and use R packages and functions\nIntroduction to Genomic Ranges\nExplore main functions for handling GRanges objects\nWork with GRanges and dplyr\nImport and inspect a GTF file\nDefine TSS genomic positions\nIntersect TSS windows with TF-bound genomic intervals\nResources for omics data\n\n\n\nDay 2 and 3\n\nIntroduction to ChIP-seq\nDataset introduction and exploration\nData normalization with edgeR\nDiagnostic and exploratory analysis\nUnderstand the theory behind differential analysis in ChIP-seq\nPerform differential analysis using edgeR\nVisualize the results\nDownstream analyses of differentially expressed genes\nPerform gene ontology analysis on interesting gene groups\nPerform gene set enrichment analysis\nInspecting data with Integrative Genome Viewer\nGenomic visualization in R\n\n\n\nDay 4 and 5\n\nIntroduction to single cell RNA sequencing\nThe Seurat object\nAnalysis of the PBMC 3K dataset\n\n\n\n\nCredits\nThis workshop was inspired by other tutorials on ChIP-seq data analysis (the Bioconductor course, the teaching material from the HBC training, the tutorial from UCR, the vignette of the GenomicRanges Package, and the Gviz User Guide. For the R fundamentals part look at this R book for beginners and the training courses at Babraham Bioinformatics. Mattia Toninelli (mattia.toninelli@ifom.eu) helped with the development of this site and some course sections. The original design of the analyses and the codes for the ChIP-seq workflow have been generated by Carolina Dossena (carolina.dossena@ifom.eu).\n\n\nLicense\nAll of the material in this course is under a Creative Commons Attribution license (CC BY 4.0) which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited."
  }
]